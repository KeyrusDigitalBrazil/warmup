import * as angular from 'angular';
declare module 'smarteditcommons' {
// ******************************************************* 
// This file is automatically generated 
// Do not modify this file -- YOUR CHANGES WILL BE ERASED! 
// ******************************************************* 

export * from './tree/types';

export * from './infiniteScrolling/YInfiniteScrollingComponent';

export * from './yMessage/yEventMessage/IYEventMessageData';
export * from './yMessage/yEventMessage/yEventMessage';
export * from './languageSelector/selector/LanguageSelectorComponent';
export * from './languageSelector/dropdown/LanguageDropdownSelectorComponent';

/// <reference types="angular" />


/**
 * @ngdoc directive
 * @name yInfiniteScrollingModule.directive:yInfiniteScrolling
 * @scope
 * @restrict E
 *
 * @description
 * A component that you can use to implement infinite scrolling for an expanding content (typically with a ng-repeat) nested in it.
 * It is meant to handle paginated requests from a backend when data is expected to be large.
 * Since the expanding content is a <b>transcluded</b> element, we must specify the context to which the items will be attached:
 * If context is myContext, each pagination will push its new items to myContext.items.
 * @param {String} pageSize The maximum size of each page requested from the backend.
 * @param {String} mask A string value sent to the server upon fetching a page to further restrict the search, it is sent as query string "mask".
 * <br>The directive listens for change to mask and will reset the scroll and re-fetch data.
 * <br/>It it left to the implementers to decide what it filters on
 * @param {String} distance A number representing how close the bottom of the element must be to the bottom of the container before the expression specified by fetchPage function is triggered. Measured in multiples of the container height; for example, if the container is 1000 pixels tall and distance is set to 2, the infinite scroll expression will be evaluated when the bottom of the element is within 2000 pixels of the bottom of the container. Defaults to 0 (e.g. the expression will be evaluated when the bottom of the element crosses the bottom of the container).
 * @param {Object} context The container object to which the items of the fetched {@link Page.object:Page Page} will be added
 * @param {Function} fetchPage function to fetch the next page when the bottom of the element approaches the bottom of the container.
 *        fetchPage will be invoked with 3 arguments : <b>mask, pageSize, currentPage</b>. The currentPage is determined by the scrolling and starts with 0. The function must return a page of type {@link Page.object:Page Page}.
 * @param {String} dropDownContainerClass An optional CSS class to be added to the container of the dropdown. It would typically be used to override the default height. <b>The resolved CSS must set a height (or max-height) and overflow-y:scroll.</b>
 * @param {String} dropDownClass An optional CSS class to be added to the dropdown. <b>Neither height nor overflow should be set on the dropdown, it must be free to fill up the space and reach the container size. Failure to do so will cause the directive to call nextPage as many times as the number of available pages on the server.</b>
 */
export class YInfiniteScrollingComponent<T extends ITechnicalUniqueIdAware> implements ISeComponent {
    
    
    
    
    
    dropDownContainerClass: string;
    dropDownClass: string;
    pageSize: number;
    mask: string;
    fetchPage: (mask: string, pageSize: number, currentPage: number) => angular.IPromise<Page<T>>;
    
    
    
    
    
}

/// <reference types="angular" />
/**
 * @ngdoc directive
 * @name SmarteditCommonsModule.component:LanguageDropdownSelectorComponent
 * @element language-dropdown-selector
 * @description
 * An icon language dropdown selector which allows the user to select a language.
 *
 * Use the {@link smarteditCommonsModule.service:LanguageService languageService}
 * to call backend API in order to get the list of supported languages
 */


export class LanguageDropdownSelectorComponent extends LanguageSelectorController {
    constructor(SWITCH_LANGUAGE_EVENT: string, languageService: LanguageService, crossFrameEventService: CrossFrameEventService, $q: angular.IQService);
    
}



/// <reference types="angular" />
/**
 * @ngdoc directive
 * @name SmarteditCommonsModule.component:LanguageSelectorComponent
 * @element language-selector
 * @description
 * A language selector which allows the user to select a language while showing the currently displayed language.
 *
 * Use the {@link smarteditCommonsModule.service:LanguageService languageService}
 * to call backend API in order to get the list of supported languages
 */


export class LanguageSelectorComponent extends LanguageSelectorController {
    constructor(SWITCH_LANGUAGE_EVENT: string, languageService: LanguageService, crossFrameEventService: CrossFrameEventService, $q: angular.IQService);
}


/**
 * @ngdoc object
 * @name treeModule.object:YTreeDndEvent
 * @description
 * A plain JSON object, representing the event triggered when dragging and dropping nodes in the {@link treeModule.directive:ytree ytree} directive.
 *
 * @param {Object} sourceNode is the {@link treeModule.object:Node node} that is being dragged.
 * @param {Object} destinationNodes is the set of the destination's parent's children {@link treeModule.object:Node nodes}.
 * @param {Number} position is the index at which the {@link treeModule.object:Node node} was dropped.
 *
 */
export class YTreeDndEvent {
    /**
     * @ngdoc property
     * @name sourceNode
     * @propertyOf treeModule.object:YTreeDndEvent
     * @description
     * the {@link treeModule.object:Node node} being dragged
     */
    sourceNode: TreeNode;
    /**
     * @ngdoc property
     * @name destinationNodes
     * @propertyOf treeModule.object:YTreeDndEvent
     * @description
     * array of siblings {@link treeModule.object:Node nodes} to the location drop location
     */
    destinationNodes: TreeNode;
    /**
     * @ngdoc property
     * @name position
     * @propertyOf treeModule.object:YTreeDndEvent
     * @description
     * the index at which {@link treeModule.object:Node node} was dropped amongst its siblings
     */
    position: number;
    /**
     * @ngdoc property
     * @name sourceParentHandle
     * @propertyOf treeModule.object:YTreeDndEvent
     * @description
     * the  UI handle of the parent node of the source element
     */
    sourceParentHandle?: any;
    /**
     * @ngdoc property
     * @name targetParentHandle
     * @propertyOf treeModule.object:YTreeDndEvent
     * @description
     * the UI handle of the targeted parent element
     */
    targetParentHandle?: any;
    constructor(
    /**
     * @ngdoc property
     * @name sourceNode
     * @propertyOf treeModule.object:YTreeDndEvent
     * @description
     * the {@link treeModule.object:Node node} being dragged
     */
    sourceNode: TreeNode, 
    /**
     * @ngdoc property
     * @name destinationNodes
     * @propertyOf treeModule.object:YTreeDndEvent
     * @description
     * array of siblings {@link treeModule.object:Node nodes} to the location drop location
     */
    destinationNodes: TreeNode, 
    /**
     * @ngdoc property
     * @name position
     * @propertyOf treeModule.object:YTreeDndEvent
     * @description
     * the index at which {@link treeModule.object:Node node} was dropped amongst its siblings
     */
    position: number, 
    /**
     * @ngdoc property
     * @name sourceParentHandle
     * @propertyOf treeModule.object:YTreeDndEvent
     * @description
     * the  UI handle of the parent node of the source element
     */
    sourceParentHandle?: any, 
    /**
     * @ngdoc property
     * @name targetParentHandle
     * @propertyOf treeModule.object:YTreeDndEvent
     * @description
     * the UI handle of the targeted parent element
     */
    targetParentHandle?: any);
}
/**
 * @ngdoc object
 * @name treeModule.object:dragOptions
 * @description
 * A JSON object holding callbacks related to nodes drag and drop functionality in the {@link treeModule.directive:ytree ytree} directive.
 * Each callback exposes the {@link treeModule.object:YTreeDndEvent YTreeDndEvent}
 */
export interface TreeDragOptions {
    /**
     * @ngdoc property
     * @name onDropCallback
     * @propertyOf treeModule.object:dragOptions
     * @description
     * Callback function executed after the node is dropped.
     */
    onDropCallback: (event: YTreeDndEvent) => void;
    /**
     * @ngdoc property
     * @name beforeDropCallback
     * @propertyOf treeModule.object:dragOptions
     * @description
     * Callback function executed before drop. Return true allows drop, false rejects, and an object {confirmDropI18nKey: 'key'} opens a confirmation modal.
     */
    beforeDropCallback: (event: YTreeDndEvent) => void;
    /**
     * @ngdoc property
     * @name acceptDropCallback
     * @propertyOf treeModule.object:dragOptions
     * @description
     * Callback function executed when hovering over droppable slots, return true to allow, return false to block.
     */
    acceptDropCallback: (event: YTreeDndEvent) => void;
    allowDropCallback: (event: YTreeDndEvent) => void;
}
export interface ITreeService {
    fetchChildren(parent: TreeNode): angular.IPromise<TreeNode[]>;
    saveNode(parent: TreeNode): angular.IPromise<TreeNode>;
    removeNode(node: TreeNode): angular.IPromise<void>;
}
/**
 * @ngdoc object
 * @name treeModule.object:Node
 * @description
 * A plain JSON object, representing the node of a tree managed by the {@link treeModule.directive:ytree ytree} directive.
 */
export interface TreeNode {
    /**
     * @ngdoc property
     * @name hasChildren
     * @propertyOf treeModule.object:Node
     * @description
     * boolean specifying whether the retrieved node has children. This is read only and ignored upon saving.
     */
    hasChildren: boolean;
    /**
     * @ngdoc property
     * @name name
     * @propertyOf treeModule.object:Node
     * @description
     * the non localized node name. Required upon posting.
     */
    name: string;
    parent: TreeNode;
    /**
     * @ngdoc property
     * @name parentUid
     * @propertyOf treeModule.object:Node
     * @description
     * the unique identifier of the parent node for the given catalog. Required upon posting.
     */
    parentUid: string;
    position: number;
    itemtype: string;
    /**
     * @ngdoc property
     * @name uid
     * @propertyOf treeModule.object:Node
     * @description
     * the unique identifier of a node for the given catalog. Optional upon posting.
     */
    uid: string;
    uuid: string;
    nodes?: TreeNode[];
    initiated?: boolean;
    mouseHovered?: boolean;
}
export interface TreeNgModel extends angular.INgModelController {
    collapsed: boolean;
    toggle: () => void;
    $parentNodeScope: any;
}

/**
 * @description
 * Interface for dropdownItem Object for {@link yDropDownMenuModule.directive:yDropDownMenu yDropDownMenu} component.
 */
export interface IYDropdownMenuItem {
    key?: string;
    icon?: string;
    template?: string;
    templateUrl?: boolean;
    callback?(): void;
    condition?(): void;
}

/**
 * @ngdoc interface
 * @name smarteditCommonsModule.interface:IYEventMessageData
 *
 * @description
 * IYEventMessageData represents the data that can optionaly be passed to the event service
 * when firing an event to show a {@link smarteditCommonsModule.directive:YEventMessage YEventMessage}
 */
export interface IYEventMessageData {
    /**
     * @ngdoc property
     * @name smarteditCommonsModule.interface:IYEventMessageData.property:description
     * @propertyOf smarteditCommonsModule.interface:IYEventMessageData
     *
     * @description
     * ```description?: string```
     *
     * The new description to be displayed in the yMessage
     */
    description?: string;
    /**
     * @ngdoc property
     * @name smarteditCommonsModule.interface:IYEventMessageData.property:title
     * @propertyOf smarteditCommonsModule.interface:IYEventMessageData
     *
     * @description
     * ```title?: string```
     *
     * The new title to be displayed in the yMessage
     */
    title?: string;
}

/// <reference types="angular" />


/**
 * @ngdoc directive
 * @name smarteditCommonsModule.directive:YEventMessage
 * @scope
 * @restrict E
 *
 * @description
 * The YEventMessage is a wrapper around YMessage, used to display or hide the message based on events sent through the systemEventService.
 *
 * @param {< string =} type The YMessage type
 * @param {< string =} title The YMessage title
 * @param {< string =} description The YMessage description
 * @param {< string =} showEvent The event id where the YMessage should be shown. You can update the message or title at this time,
 * by passing a {@link smarteditCommonsModule.interface:IYEventMessageData IYEventMessageData} as argument to the event service.
 * @param {< string =} hideEvent The event id where the YMessage should be hidden
 * @param {< string =} showToStart Controls whether the component is shown right away after compiling the dom
 */
export class YEventMessageComponent implements ISeComponent {
    
    type: string;
    title: string;
    description: string;
    show: boolean;
    showToStart: string | boolean;
    recompile: () => void;
    
    
    $onChanges(changesObj: angular.IOnChangesObject): void;
    $onInit(): void;
    $onDestroy(): void;
    showDescription(): boolean;
    showTitle(): boolean;
    showEventHandler(eventId: string, eventData: IYEventMessageData): void;
    
    
}

/// <reference types="angular-translate" />



/**
 * @ngdoc directive
 * @name SmarteditCommonsModule.component:yMoreTextComponent
 * @element more-text
 * @description
 * The component for truncating strings and adding an ellipsis.
 * If the limit is less then the string length then the string is truncated and 'more'/'less' buttons
 * are displayed to expand or collapse the string.
 *
 * @param {< String} text the text to be displayed
 * @param {< String =} limit index in text to truncate to. Default value is 100.
 * @param {< String =} moreLabelI18nKey the label property value for a more button. Default value is 'more'.
 * @param {< String =} lessLabelI18nKey the label property value for a less button. Default value is 'less'.
 * @param {< String =} ellipsis the ellipsis for a truncated text. Default value is an empty string.
 */
export class YMoreTextComponent implements ISeComponent {
    
    
    
    text: string;
    linkLabel: string;
    isTruncated: boolean;
    
    
    
    
    
    
    
    
    constructor(textTruncateService: TextTruncateService, $translate: angular.translate.ITranslateService, $q: angular.IQService);
    $onInit(): void;
    showHideMoreText(): void;
    translateLabels(): angular.IPromise<any>;
}

/// <reference types="angular" />
/**
 * @ngdoc directive
 * @name smarteditCommonsModule.directive:compileHtml
 * @scope
 * @restrict A
 * @attribute compile-html
 *
 * @description
 * Directive responsible for evaluating and compiling HTML markup.
 *
 * @param {String} String HTML string to be evaluated and compiled in the parent scope.
 * @example
 * <pre>
 *      <div compile-html="<a data-ng-click=\"injectedContext.onLink( item.path )\">{{ item[key.property] }}</a>"></div>
 * </pre>
 */
export class CompileHtmlDirective {
    
    
    
    
    constructor($compile: angular.ICompileService, $scope: angular.IScope, $element: JQuery<HTMLElement>, $attrs: angular.IAttributes);
    $postLink(): void;
}

export * from './CompileHtmlDirective';



export type Cloneable = Primitive | Primitive[] | Payload;
/**
 * @ngdoc service
 * @name functionsModule.service:CloneableUtils
 *
 * @description
 * utility service around Cloneable objects
 */
export class CloneableUtils {
    
    constructor(lodash: lo.LoDashStatic);
    /**
     * @ngdoc method
     * @name functionsModule.service:CloneableUtils#makeCloneable
     * @methodOf functionsModule.service:CloneableUtils
     * @description
     * returns a "cloneable" version of an object.
     * Something is cloneable when it can be sent through W3C postMessage.
     * To this purpose, functions must be removed from the cloneable candidate.
     * @param {Object} json the object to be made cloneable
     * @returns {Cloneable} the cloneable copy of the object
     */
    makeCloneable(_json: any): Cloneable;
    
}

/**
 * We are doing forced imports in order to generate the types (d.ts) of below interfaces or classes correctly.
 * If we don't include the below imports, as a part of webpack tree shaking, the types will not be generated.
 * There is an open issue in typescript github regarding forced imports
 * https://github.com/Microsoft/TypeScript/issues/9191
 * https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-imports-being-elided-in-my-emit
 *
 * If an interface X extends an interface Y, make sure X has all types it needs from Y by checking index.d.ts, if not, do force 
 */













/** from Backend */
export interface IBaseCatalogVersion extends Payload {
    active: boolean;
    pageDisplayConditions: {
        options: {
            id: string;
            label: string;
        }[];
        typecode: string;
    }[];
    uuid: string;
    version: string;
    thumbnailUrl?: string;
}
export interface ICatalogVersion extends IBaseCatalogVersion {
    name?: {
        [index: string]: string;
    };
    catalogId?: string;
    catalogName?: TypedMap<string>;
    siteDescriptor?: ISite;
    homepage?: IHomepageVersions;
}
export interface IBaseCatalog {
    catalogId: string;
    versions: IBaseCatalogVersion[];
    name?: TypedMap<string>;
}
export interface ICatalog {
    catalogId: string;
    versions: ICatalogVersion[];
    name?: TypedMap<string>;
}
export interface IBaseCatalogs {
    catalogs: IBaseCatalog[];
}
export interface ICatalogs {
    catalogs: ICatalog[];
}


export interface IHomepageVersions extends Payload {
    current?: IHomepage;
    old?: IHomepage;
    fallback?: IHomepage;
}
export interface IHomepage extends Payload {
    uid: string;
    name: string;
    catalogVersionUuid: string;
}













export * from './ICatalog';
export * from './IHomepage';

/**
 * Key value pairs where the key is the permission and the value is a boolean string
 * Used in IPermissionsRestServiceResult
 */
export interface IPermissionsRestServicePair {
    key: string;
    value: string;
}
/**
 * Result of getting permissions form the PermissionsRestService.get
 */
export interface IPermissionsRestServiceResult {
    id?: string;
    permissions: IPermissionsRestServicePair[];
}
/**
 * The input param type for PermissionsRestService.get
 */
export interface IPermissionsRestServiceQueryData {
    user: string;
    permissionNames: string;
}


/**
 * @ngdoc object
 * @name Page.object:Page
 * @description
 * An object representing the backend response to a paged query
 */
export interface Page<T> {
    /**
     * @ngdoc object
     * @name Page.object:Pagination
     * @description
     * An object representing the returned pagination information from backend
     */
    pagination: Pagination;
    /**
     * @ngdoc property
     * @name results
     * @propertyOf Page.object:Page
     * @description
     * The array containing the elements pertaining to the requested page, its size will not exceed the requested page size.
     */
    results: T[];
    [index: string]: T[] | Pagination;
}


export interface Pageable extends Payload {
    currentPage: number;
    mask?: string;
    pageSize?: number;
    sort?: string;
}

export interface Pagination {
    totalCount: number;
}


export interface Payload {
    [index: string]: Primitive | Primitive[] | Payload | Payload[];
}

export type Primitive = string | number | boolean;



export interface TypedMap<T> {
    [index: string]: T;
}

/**
 * @ngdoc object
 * @name ValidationError.object:ValidationError
 * @description
 * An object representing the backend response for any erroy of type "ValidationError"
 */
export interface ValidationError {
    language?: string;
    message: string;
    reason: string;
    subject: string;
    subjectType: string;
    errorCode: string;
    type: "ValidationError";
}

export * from './dtos';
export * from './services';
export * from './components';
export * from './directives';
export * from './modules';
export * from './utils';

export * from './translations/translationServiceModule';





/**
 * @ngdoc service
 * @name translationServiceModule
 *
 * @description
 *
 * This module is used to configure the translate service, the filter, and the directives from the 'pascalprecht.translate' package. The configuration consists of:
 *
 * <br/>- Initializing the translation map from the {@link i18nInterceptorModule.object:I18NAPIROOT I18NAPIROOT} constant.
 * <br/>- Setting the preferredLanguage to the {@link i18nInterceptorModule.object:UNDEFINED_LOCALE UNDEFINED_LOCALE} so that the {@link i18nInterceptorModule.service:i18nInterceptor#methods_request i18nInterceptor request} can replace it with the appropriate URI combined with the runtime browser locale retrieved from browserService.getBrowserLocale, which is unaccessible at configuration time.
 */
export class TranslationServiceModule {
}



/**
 * @ngdoc object
 * @name NoModule.object:MethodAnnotation
 *
 * @description
 * Shorthand signature of a {@link https://www.typescriptlang.org/docs/handbook/decorators.html Typescript Decorator} function for methods
 * used by {@link NoModule.service:AnnotationService AnnotationService}.
 * @param {any} target the instance the method of which is annotated
 * @param {any} propertyName the name of the method that is annotated
 * @param {any} originalMethod the original method being annotated, it is prebound to the instance
 * @returns {any} the final return value of the proxied method.
 * It is left to implementers to discard, modify, reuse the original method.
 */
export type MethodAnnotation = (target: any, propertyName: string, originalMethod: (...x: any[]) => any, ...invocationArguments: any[]) => any;
/**
 * @ngdoc object
 * @name NoModule.object:MethodAnnotationFactory
 *
 * @description
 * A {@link NoModule.object:MethodAnnotation MethodAnnotation} factory
 * used by {@link NoModule.service:AnnotationService AnnotationService}.
 * @param {...any[]} factoryArguments the factory arguments
 * @returns {MethodAnnotation} {@link NoModule.object:MethodAnnotation MethodAnnotation}
 */
export type MethodAnnotationFactory = (...factoryArguments: any[]) => MethodAnnotation;
/**
 * @ngdoc object
 * @name NoModule.object:ClassAnnotation
 *
 * @description
 * Shorthand signature of a {@link https://www.typescriptlang.org/docs/handbook/decorators.html Typescript Decorator} function for classes
 * used by {@link NoModule.service:AnnotationService AnnotationService}.
 * @param {any} instance an instance of the class which is annotated
 * @param {(...x: any[]) => any} originalConstructor the prebound original constructor of the instance
 * @param {...any[]} invocationArguments the arguments with which the constructor is invoked
 * @returns {any} void or a new instance.
 * It is left to implementers to discard, modify, or reuse the original constructor then not to return or return a new instance.
 */
export type ClassAnnotation = (instance: any, originalConstructor: (...x: any[]) => any, ...invocationArguments: any[]) => any;
/**
 * @ngdoc object
 * @name NoModule.object:ClassAnnotationFactory
 *
 * @description
 * A {@link NoModule.object:ClassAnnotation ClassAnnotation} factory
 * used by {@link NoModule.service:AnnotationService AnnotationService}.
 * @param {...any[]} factoryArguments the factory arguments
 * @returns {ClassAnnotation} {@link NoModule.object:ClassAnnotation ClassAnnotation}
 */
export type ClassAnnotationFactory = (...x: any[]) => ClassAnnotation;
/**
 * @ngdoc service
 * @name NoModule.service:AnnotationService
 *
 * @description
 * Utility service to declare and consume method level and class level {@link https://www.typescriptlang.org/docs/handbook/decorators.html Typescript decorator factories}.
 * <br/>Since Decorator is a reserved word in Smartedit, Typescript Decorators are called as Annotations.
 */
export class AnnotationService {
    readonly INJECTABLE_NAME_KEY: string;
    readonly ORIGINAL_CONSTRUCTOR_KEY: string;
    /**
     * @ngdoc method
     * @name NoModule.service:AnnotationService#getClassAnnotations
     * @methodOf NoModule.service:AnnotationService
     *
     * @description
     * Retrieves an object with all the string-indexed annotations defined on the given class target
     * @param {any} target The typescript class on which class annotations are defined
     * @returns {[index: string]: any} an object contains string-indexed annotation name and payload
     */
    getClassAnnotations: ((target: any) => TypedMap<any>) & lo.MemoizedFunction;
    /**
     * @ngdoc method
     * @name NoModule.service:AnnotationService#getMethodAnnotations
     * @methodOf NoModule.service:AnnotationService
     *
     * @description
     * Retrieves an object with all the string indexed annotations defined on the given class method
     * @param {any} target The typescript class to the inspected
     * @param {string} propertyName The name of the method on which annotations are defined
     * @returns {[index: string]: any} an object contains string-indexed annotation name and payload
     */
    getMethodAnnotations: ((target: any, propertyName: string) => TypedMap<any>) & lo.MemoizedFunction;
    
    
    /**
     * @ngdoc method
     * @name NoModule.service:AnnotationService#getClassAnnotation
     * @methodOf NoModule.service:AnnotationService
     *
     * @description
     * Retrieves arguments of class annotation under a given annotation name
     * @param {any} target The typescript class on which class annotation is defined
     * @param {(args?: any) => ClassDecorator} annotation The type of the class annotation
     * @returns {any} the payload passed to the annotation
     */
    getClassAnnotation(target: any, annotation: (args?: any) => ClassDecorator): any;
    /**
     * @ngdoc method
     * @name NoModule.service:AnnotationService#getMethodAnnotation
     * @methodOf NoModule.service:AnnotationService
     *
     * @description
     * Retrieves arguments of method annotation for a given typescript class
     * @param {any} target The typescript class
     * @param {string} propertyName The name of the method on which annotation is defined
     * @param {(args?: any) => MethodDecorator)} annotation The type of the method annotation
     * @returns {any} the payload passed to the annotation
     */
    getMethodAnnotation(target: any, propertyName: string, annotation: (args?: any) => MethodDecorator): any;
    /**
     * @ngdoc method
     * @name NoModule.service:AnnotationService#hasClassAnnotation
     * @methodOf NoModule.service:AnnotationService
     *
     * @description
     * Determines whether a given class target has given annotation name defined or not
     * @param {any} target The typescript class on which class annotation is defined
     * @param {(args?: any) => ClassDecorator} annotation The type of the class annotation
     * @returns {boolean} true if a given target has given annotation name. Otherwise false.
     */
    hasClassAnnotation(target: any, annotation: (args?: any) => ClassDecorator): boolean;
    /**
     * @ngdoc method
     * @name NoModule.service:AnnotationService#hasMethodAnnotation
     * @methodOf NoModule.service:AnnotationService
     *
     * @description
     * Determines whether a given method name has given annotation name defined or not under a given typescript class
     * @param {any} target The typescript class object
     * @param {string} propertyName The name of the method on which annotation is defined
     * @param {(args?: any) => MethodDecorator} annotation The type of the method annotation
     * @returns {boolean} true if a given method name has given annotation name. Otherwise false.
     */
    hasMethodAnnotation(target: any, propertyName: string, annotation: (args?: any) => MethodDecorator): boolean;
    /**
     * @ngdoc method
     * @name NoModule.service:AnnotationService#setClassAnnotationFactory
     * @methodOf NoModule.service:AnnotationService
     *
     * @description
     * Registers a {@link NoModule.object:ClassAnnotationFactory ClassAnnotationFactory} under a given name.
     * <br/>Typically, in order for the ClassAnnotationFactory to benefit from Angular dependency injection, this method will be called within an Angular factory.
     * @param {string} name the name of the factory.
     * @returns {ClassAnnotationFactory} a {@link NoModule.object:ClassAnnotationFactory ClassAnnotationFactory}
     */
    setClassAnnotationFactory(name: string, annotationFactory: ClassAnnotationFactory): ClassAnnotationFactory;
    /**
     * @ngdoc method
     * @name NoModule.service:AnnotationService#getClassAnnotationFactory
     * @methodOf NoModule.service:AnnotationService
     *
     * @description
     * Retrieves a {@link NoModule.object:ClassAnnotationFactory ClassAnnotationFactory}
     * previously registered under the given name:
     *
     * <pre>
     *   export const GatewayProxied = annotationService.getClassAnnotationFactory('GatewayProxied');
     * </pre>
     *
     * @param {string} name The name of the factory
     * @returns {ClassAnnotationFactory} a {@link NoModule.object:ClassAnnotationFactory ClassAnnotationFactory}
     */
    getClassAnnotationFactory(name: string): (...args: any[]) => ClassDecorator;
    /**
     * @ngdoc method
     * @name NoModule.service:AnnotationService#setMethodAnnotationFactory
     * @methodOf NoModule.service:AnnotationService
     *
     * @description
     * Registers a {@link NoModule.object:MethodAnnotationFactory MethodAnnotationFactory} under a given name.
     * <br/>Typically, in order for the MethodAnnotationFactory to benefit from Angular dependency injection, this method will be called within an Angular factory.
     * @param {string} name The name of the factory.
     * @returns {MethodAnnotationFactory} a {@link NoModule.object:MethodAnnotationFactory MethodAnnotationFactory}
     */
    setMethodAnnotationFactory(name: string, annotationFactory: MethodAnnotationFactory): MethodAnnotationFactory;
    /**
     * @ngdoc method
     * @name NoModule.service:AnnotationService#getMethodAnnotationFactory
     * @methodOf NoModule.service:AnnotationService
     *
     * @description
     * Retrieves a method level {@link NoModule.object:MethodAnnotationFactory MethodAnnotationFactory}
     * previously registered under the given name:
     *
     * <pre>
     *   export const Cached = annotationService.getMethodAnnotationFactory('Cached');
     * </pre>
     *
     * @param {string} name the name of the factory.
     * @returns {MethodAnnotationFactory} a {@link NoModule.object:MethodAnnotationFactory MethodAnnotationFactory}.
     */
    getMethodAnnotationFactory(name: string): (...factoryArgument: any[]) => (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<(...x: any[]) => any>) => void;
    /**
     * @ngdoc method
     * @name NoModule.service:AnnotationService#getOriginalConstructor
     * @methodOf NoModule.service:AnnotationService
     *
     * @description
     * Given a class constructor, returns the original constructor of it prior to any class level
     * proxying by annotations declared through {@link NoModule.service:AnnotationService AnnotationService}
     *
     * @param {SeConstructor} target the constructor
     */
    getOriginalConstructor(target: any): SeConstructor;
    
    
}
export const annotationService: AnnotationService;

/// <reference types="angular" />
/// <reference types="angular-mocks" />


/**
 * @ngdoc service
 * @name smarteditCommonsModule.service.AuthorizationService
 *
 * @description
 * This service makes calls to the Global Permissions REST API to check if the current user was
 * granted certain permissions.
 */
export class AuthorizationService {
    
    
    
    static ERR_INVALID_PERMISSION_NAMES: Error;
    constructor($log: angular.ILogService, sessionService: ISessionService, permissionsRestService: PermissionsRestService);
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service.AuthorizationService#hasGlobalPermissions
     * @methodOf smarteditCommonsModule.service.AuthorizationService
     *
     * @description
     * This method checks if the current user is granted the given global permissions.
     *
     * @param {String[]} permissionNames The list of global permissions to check.
     *
     * @return {Boolean} true if the user is granted all of the given permissions, false otherwise
     *
     * @throws Will throw an error if the permissionNames array is empty
     */
    hasGlobalPermissions(permissionNames: string[]): angular.IPromise<boolean>;
    
    
    
}


export const FrequentlyChangingContentName: string;
export const frequentlyChangingContent: CacheAction;

export * from './frequentlyChangingContent';
export * from './rarelyChangingContent';


export const rarelyChangingContent: CacheAction;

/**
 * @ngdoc object
 * @name smarteditServicesModule.object:CacheAction
 * @description
 * A {@link smarteditServicesModule.object:@Cached @Cached} annotation is associated to a CacheAction.
 */
export class CacheAction {
    name: string;
    constructor(name: string);
}

/// <reference types="angular" />
/// <reference types="angular-mocks" />



export const CacheConfig: (args: {
    actions?: CacheAction[];
    tags?: EvictionTag[];
}) => ClassDecorator;
export function CacheConfigAnnotationFactory($log: angular.ILogService): import("smarteditcommons/services/annotationService").ClassAnnotationFactory;
export const Cached: (args?: {
    actions: CacheAction[];
    tags?: EvictionTag[];
}) => MethodDecorator;
export function CachedAnnotationFactory(cacheService: CacheService): import("smarteditcommons/services/annotationService").MethodAnnotationFactory;
export const InvalidateCache: (tag?: EvictionTag) => (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<(...x: any[]) => any>) => void;
export function InvalidateCacheAnnotationFactory(cacheService: CacheService): import("smarteditcommons/services/annotationService").MethodAnnotationFactory;






export type ICachePredicate = (cacheActions: CacheAction[]) => boolean;
/**
 * @ngdoc service
 * @name smarteditServicesModule.service:CacheService
 * @description
 * Service to which the {@link smarteditServicesModule.object:@Cached @Cached} and {@link smarteditServicesModule.object:@InvalidateCache @InvalidateCache} annotations delegate to perform service method level caching.
 * It is not handled explicitly except for its evict method.
 */
export class CacheService {
    
    
    
    
    
    
    
    
    
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:CacheService#register
     * @methodOf smarteditServicesModule.service:CacheService
     *
     * @description
     * Register a new predicate with it's associated cacheTiming.
     * Each time the @Cache annotation is handled, the CacheService try to find a matching cacheTiming for the given cacheActions.
     *
     * @param {ICachePredicate} test This function takes the cacheActions {@link smarteditServicesModule.object:CacheAction CacheAction} argument, and must return a Boolean that is true if the given cacheActions match the predicate.
     * @param {ICacheTiming} cacheTiming This function is used to call setAge(item: ICacheItem<any>) on the cached item.
     *
     * @return {CacheService} CacheService The CacheService instance.
     *
     * @example
     * ```ts
     * export class CustomCacheTiming implements ICacheTiming {
     * 	
     * 	
     *  constructor(expirationAge: number, refreshAge: number) {
     * 		// The cached response is discarded if it is older than the expiration age.
     * 		this.expirationAge = expirationAge;
     * 		// maximum age for the cached response to be considered "fresh."
     * 		this.refreshAge = refreshAge;
     * 	}
     * 	setAge(item: ICacheItem<any>): void {
     * 		item.expirationAge = this.expirationAge;
     * 		item.refreshAge = this.refreshAge;
     * 	}
     * 	};
     * 	const customCacheTiming = new CustomCacheTiming(30 * 60000, 15 * 60000);
     * 	const customContentPredicate: ICachePredicate = (cacheActions: CacheAction[]) => {
     * 		return cacheActions.find((cacheAction) => cacheAction.name === 'CUSTOM_TAG') !== null;
     * 	};
     * this.register(customContentPredicate, customCacheTiming);
     * ```
     */
    register(test: ICachePredicate, cacheTiming: ICacheTiming): CacheService;
    /**
     * public method but only meant to be used by @Cache annotation
     */
    handle<T extends IMetadata>(service: any, methodName: string, preboundMethod: (...args: any[]) => T, invocationArguments: any[], cacheActions: CacheAction[], tags: EvictionTag[]): angular.IPromise<T>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:CacheService#evict
     * @methodOf  smarteditServicesModule.service:CacheService
     * @description
     * Will evict the entire cache of all methods of all services referencing either directly or indirectly the given {@link smarteditServicesModule.object:EvictionTag EvictionTags}
     * @param {...EvictionTag[]} evictionTags the {@link smarteditServicesModule.object:EvictionTag EvictionTags}
     */
    evict(...evictionTags: EvictionTag[]): void;
    
    
    
    
    
}




export class DefaultCacheTiming implements ICacheTiming {
    
    
    constructor(expirationAge: number, refreshAge: number);
    setAge(item: ICacheItem<any>): void;
}

export * from './CacheEngine';
export * from './DefaultCacheTiming';
export * from './interfaces';

/**
 * @ngdoc object
 * @name smarteditServicesModule.object:EvictionTag
 * @description
 * A {@link smarteditServicesModule.object:@Cached @Cached} annotation is tagged with 0 to n EvictionTag, each EvictionTag possibly referencing other evictionTags.
 * <br/>An EvictionTag enables a method cache to be evicted 2 different ways:
 * <ul>
 * <li> An event with the same name as the tag is raised.</li>
 * <li> {@link smarteditServicesModule.service:CacheService#methods_evict evict} method of {@link smarteditServicesModule.service:CacheService cacheService} is invoked with the tag.</li>
 * </ul>
 */
export class EvictionTag {
    /**
     * @ngdoc property
     * @name name
     * @propertyOf smarteditServicesModule.object:EvictionTag
     * @description
     * event upon which the cache should be cleared.
     */
    event: string;
    /**
     * @ngdoc property
     * @name relatedTags
     * @propertyOf smarteditServicesModule.object:EvictionTag
     * @description
     * other EvictionTag instances grouped under this evictionTag.
     */
    relatedTags?: EvictionTag[];
    constructor(args: {
        event: string;
        relatedTags?: EvictionTag[];
    });
}

export * from './cachedAnnotation';
export * from './CacheAction';
export * from './CacheService';
export * from './EvictionTag';
export * from './actions';
export * from './engine';
export * from './tags';


export const authorizationEvictionTag: EvictionTag;


export const catalogSyncedEvictionTag: EvictionTag;
export const catalogEvictionTag: EvictionTag;


export const contentCatalogUpdateEvictionTag: EvictionTag;

export * from './authorizationEvictionTag';
export * from './catalogEvictionTag';
export * from './pageEvictionTag';
export * from './userEvictionTag';
export * from './contentCatalogUpdateEvictionTag';


export const pageCreationEvictionTag: EvictionTag;
export const pageDeletionEvictionTag: EvictionTag;
export const pageUpdateEvictionTag: EvictionTag;
export const pageRestoredEvictionTag: EvictionTag;
export const pageChangeEvictionTag: EvictionTag;
export const pageEvictionTag: EvictionTag;


export const userEvictionTag: EvictionTag;






/**
 * @ngdoc service
 * @name smarteditCommonsModule.service:CrossFrameEventService
 *
 * @description
 * The Cross Frame Event Service is responsible for publishing and subscribing events within and between frames.
 * It uses {@link smarteditCommonsModule.service:GatewayFactory gatewayFactory} and {@link smarteditCommonsModule.service:SystemEventService EventService} to transmit events.
 *
 */
export class CrossFrameEventService {
    
    
    
    
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:CrossFrameEventService#publish
     * @methodOf smarteditCommonsModule.service:CrossFrameEventService
     *
     * @description
     * Publishes an event within and across the gateway.
     *
     * The publish method is used to send events using {@link smarteditCommonsModule.SystemEventService#publishAsync publishAsync} of
     * {@link smarteditCommonsModule.SystemEventService SystemEventService} and as well send the message across the gateway by using
     * {@link smarteditCommonsModule.service:MessageGateway#publish publish} of the {@link smarteditCommonsModule.service:GatewayFactory gatewayFactory}.
     *
     * @param {String} eventId Event identifier
     * @param {any=} data The event payload. It is an optional paramter.
     * @returns {angular.IPromise<[any, any]>} Promise to resolve
     */
    publish(eventId: string, data?: any): angular.IPromise<any[]>;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:CrossFrameEventService#subscribe
     * @methodOf smarteditCommonsModule.service:CrossFrameEventService
     *
     * @description
     * Subscribe to an event across both frames.
     *
     * The subscribe method is used to register for listening to events using subscribe method of
     * {@link smarteditCommonsModule.SystemEventService SystemEventService} and as well send the registration message across the gateway by using
     * {@link smarteditCommonsModule.service:MessageGateway#subscribe subscribe} of the {@link smarteditCommonsModule.service:GatewayFactory gatewayFactory}.
     *
     * @param {String} eventId Event identifier
     * @param {CloneableEventHandler} handler Callback function to be invoked
     * @returns {() => void} The function to call in order to unsubscribe the event listening; this will unsubscribe both from the systemEventService and the crossFrameEventServiceGatway
     */
    subscribe<T extends Cloneable>(eventId: string, handler: CloneableEventHandler<T>): () => void;
}



export * from './SeInjectable';
export * from './SeComponent';
export * from './SeDirective';
export * from './ISeComponent';
export * from './SeModule';
export * from './types';
export * from './DINameUtils';

export const diNameUtils: DINameUtils;

export interface IChangesObject<T> {
    currentValue: T;
    previousValue: T;
    isFirstChange(): boolean;
}
export interface IOnChangesObject {
    [property: string]: IChangesObject<any>;
}
export interface ISeComponent {
    /**
     * Called on each controller after all the controllers on an element have been constructed and had their bindings
     * initialized (and before the pre & post linking functions for the directives on this element). This is a good
     * place to put initialization code for your controller.
     */
    $onInit?(): void;
    /**
     * Called on each turn of the digest cycle. Provides an opportunity to detect and act on changes.
     * Any actions that you wish to take in response to the changes that you detect must be invoked from this hook;
     * implementing this has no effect on when `$onChanges` is called. For example, this hook could be useful if you wish
     * to perform a deep equality check, or to check a `Date object, changes to which would not be detected by Angular's
     * change detector and thus not trigger `$onChanges`. This hook is invoked with no arguments; if detecting changes,
     * you must store the previous value(s) for comparison to the current values.
     */
    $doCheck?(): void;
    /**
     * Called whenever one-way bindings are updated. The onChangesObj is a hash whose keys are the names of the bound
     * properties that have changed, and the values are an {@link IChangesObject} object  of the form
     * { currentValue, previousValue, isFirstChange() }. Use this hook to trigger updates within a component such as
     * cloning the bound value to prevent accidental mutation of the outer value.
     */
    $onChanges?(onChangesObj: IOnChangesObject): void;
    /**
     * Called on a controller when its containing scope is destroyed. Use this hook for releasing external resources,
     * watches and event handlers.
     */
    $onDestroy?(): void;
    /**
     * Called after this controller's element and its children have been linked. Similar to the post-link function this
     * hook can be used to set up DOM event handlers and do direct DOM manipulation. Note that child elements that contain
     * templateUrl directives will not have been compiled and linked since they are waiting for their template to load
     * asynchronously and their own compilation and linking has been suspended until that occurs.
     */
    $postLink?(): void;
    [index: string]: any;
}


export const SeComponent: (definition: SeComponentDefinition) => <T extends SeComponentConstructor>(componentConstructor: T) => T;


export const SeDirective: (definition: SeDirectiveDefinition) => (directiveConstructor: SeDirectiveConstructor) => SeDirectiveConstructor;

export const SeInjectable: () => (providerConstructor: any) => any;


export const SeModule: (definition: {
    declarations?: (SeComponentConstructor | SeDirectiveConstructor)[];
    imports?: (string | SeModuleConstructor | SeModuleWithProviders)[];
    providers?: SeProvider[];
    config?: (...args: any[]) => void;
    initialize?: (...args: any[]) => void;
}) => <T extends SeModuleConstructor>(moduleConstructor: T) => T;



export interface SeDirectiveDefinition {
    selector?: string;
    inputs?: string[];
    providers?: SeProvider[];
    require?: string | string[] | TypedMap<string>;
}
export interface SeComponentDefinition extends SeDirectiveDefinition {
    templateUrl?: string;
    template?: string;
    entryComponents?: SeComponentConstructor[];
}
export type SeFactory = (...arg: any[]) => any;
export interface SeConstructor {
    new (...arg: any[]): any;
}
export interface SeModuleConstructor extends SeConstructor {
    moduleName?: string;
}
export interface SeDirectiveConstructor extends SeConstructor {
    directiveName?: string;
    definition?: angular.IDirective;
    providers?: SeProvider[];
}
export interface SeComponentConstructor extends SeConstructor {
    componentName?: string;
    definition?: angular.IComponentOptions;
    entryComponents?: SeComponentConstructor[];
    providers?: SeProvider[];
}
export interface SeBaseProvider {
    provide: string;
    multi?: boolean;
}
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:SeValueProvider
 * @description
 * Configures an injectable value provider in a {@link smarteditServicesModule.object:@SeModule module}, component or directive.
 */
export interface SeValueProvider extends SeBaseProvider {
    /**
     * @ngdoc property
     * @name provide
     * @propertyOf smarteditServicesModule.interface:SeValueProvider
     * @description
     * The provider name.
     */
    /**
     * @ngdoc property
     * @name useValue
     * @propertyOf smarteditServicesModule.interface:SeValueProvider
     * @description
     * An instance value of the provider.
     */
    useValue: any;
}
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:SeClassProvider
 * @description
 * Configures an injectable class provider in a {@link smarteditServicesModule.object:@SeModule module}, component or directive.
 */
export interface SeClassProvider extends SeBaseProvider {
    /**
     * @ngdoc property
     * @name provide
     * @propertyOf smarteditServicesModule.interface:SeClassProvider
     * @description
     * The provider name.
     */
    /**
     * @ngdoc property
     * @name useClass
     * @propertyOf smarteditServicesModule.interface:SeClassProvider
     * @description
     * A class to invoke of the provider.
     */
    useClass: SeConstructor;
}
/**
 * @ngdoc object
 * @name smarteditServicesModule.interface:SeFactoryProvider
 * @description
 * Configures an injectable factory provider in a {@link smarteditServicesModule.object:@SeModule module}, component or directive.
 */
export interface SeFactoryProvider extends SeBaseProvider {
    /**
     * @ngdoc property
     * @name provide
     * @propertyOf smarteditServicesModule.interface:SeFactoryProvider
     * @description
     * The provider name.
     */
    /**
     * @ngdoc property
     * @name useFactory
     * @propertyOf smarteditServicesModule.interface:SeFactoryProvider
     * @description
     * A function to invoke the construction of the provider.
     */
    useFactory: SeFactory;
    /**
     * @ngdoc property
     * @name deps (optional)
     * @propertyOf smarteditServicesModule.interface:SeFactoryProvider
     * @description
     * A list of strings or referenced dependencies to be injected into the factory. The 'ngInject;' hint may be used
     * in replacement of this property.
     */
    deps?: (SeConstructor | SeFactory | string)[];
}
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:SeModuleWithProviders
 * @description
 * The returning type of a configurable module.
 */
export interface SeModuleWithProviders {
    seModule: SeModuleConstructor;
    providers: SeProvider[];
}
export type SeProvider = SeValueProvider | SeClassProvider | SeFactoryProvider | SeConstructor | SeFactory;

export const deprecate: () => void;


export interface IDragAndDropEvents {
    TRACK_MOUSE_POSITION: string;
    DROP_ELEMENT: string;
    DRAG_DROP_START: string;
    DRAG_DROP_END: string;
    DRAG_DROP_CROSS_ORIGIN_START: string;
}
/**
 * @ngdoc object
 * @name smarteditServicesModule.object:IMousePosition
 * @description
 * Pointer coordinates
 */
export interface IMousePosition extends Payload {
    /**
     * @ngdoc property
     * @name x
     * @propertyOf smarteditServicesModule.object:IMousePosition
     * @description
     * abscissa of the pointer position
     */
    x: number;
    /**
     * @ngdoc property
     * @name y
     * @propertyOf smarteditServicesModule.object:IMousePosition
     * @description
     * ordinate of the pointer position
     */
    y: number;
}
export type IDragEventType = 'drop' | 'dragenter' | 'dragover' | 'dragleave';
export const IDragEventType: {
    DROP: IDragEventType;
    DRAG_ENTER: IDragEventType;
    DRAG_OVER: IDragEventType;
    DRAG_LEAVE: IDragEventType;
};
export interface IDragAndDropScrollingService {
    toggleThrottling(isEnabled: boolean): void;
}

export * from './IDragAndDropScrollingService';
export * from './InViewElementObserver';


export interface QueueElement {
    component: HTMLElement;
    isIntersecting: boolean;
}
/**
 * @ngdoc service
 * @name smarteditServicesModule.service:InViewElementObserver
 * @description
 * InViewElementObserver maintains a collection of eligible DOM elements considered "in view".
 * <br/>An element is considered eligible if matches at least one of the selectors passed to the service.
 * <br/>An eligible element is in view when and only when it intersects with the view port of the window frame.
 * <br/>This services provides as well convenience methods around "in view" components:
 */
export class InViewElementObserver {
    
    
    
    
    
    
    
    
    
    
    
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:InViewElementObserver#elementFromPoint
     * @methodOf smarteditServicesModule.service:InViewElementObserver
     * @description
     * Retrieves the element targeted by the given mousePosition.
     * <br/>On some browsers, the native Javascript API will not work when targeting
     * an element inside an iframe from the container if a container overlay blocks it.
     * <br/>In such case we resort to returning the targeted element amongst the list of "in view" elements
     * @param {IMousePosition} mousePosition the fixed {@link smarteditServicesModule.object:IMousePosition coordinates} of the pointer
     */
    elementFromPoint(mousePosition: IMousePosition): Element;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:InViewElementObserver#addSelector
     * @methodOf smarteditServicesModule.service:InViewElementObserver
     * @description
     * Declares a new yjQuery selector in order to observe more elements.
     * @param {string[]} selector a {@link https://jquery.com jquery} selector
     */
    addSelector(selector: string): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:InViewElementObserver#getAllElements
     * @methodOf smarteditServicesModule.service:InViewElementObserver
     * @description
     * Retrieves the full list of eligible DOM elements even if they are not "in view".
     * @return {Element[]} An array of DOM elements
     */
    getAllElements(): Element[];
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:InViewElementObserver#getInViewElements
     * @methodOf smarteditServicesModule.service:InViewElementObserver
     * @description
     * Retrieves the list of currently "in view" DOM elements.
     * @return {Element[]} An array of DOM elements
     */
    getInViewElements(): Element[];
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}





/**
 * We are doing forced imports in order to generate the types (d.ts) of below interfaces or classes correctly.
 * If we don't include the below imports, as a part of webpack tree shaking, the types will not be generated.
 * There is an open issue in typescript github regarding forced imports
 * https://github.com/Microsoft/TypeScript/issues/9191
 * https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-imports-being-elided-in-my-emit
 *
 * If an interface X extends an interface Y, make sure X has all types it needs from Y by checking index.d.ts, if not, do force 
 */


























/**
 * @ngdoc service
 * @name smarteditCommonsModule.service:GatewayFactory
 *
 * @description
 * The Gateway Factory controls the creation of and access to {@link smarteditCommonsModule.service:MessageGateway MessageGateway}
 * instances.
 *
 * To construct and access a gateway, you must use the GatewayFactory's createGateway method and provide the channel
 * ID as an argument. If you try to create the same gateway twice, the second call will return a null.
 */
export class GatewayFactory {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:GatewayFactory#initListener
     * @methodOf smarteditCommonsModule.service:GatewayFactory
     *
     * @description
     * Initializes a postMessage event handler that dispatches the handling of an event to the specified gateway.
     * If the corresponding gateway does not exist, an error is logged.
     */
    initListener(): void;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:GatewayFactory#createGateway
     * @methodOf smarteditCommonsModule.service:GatewayFactory
     *
     * @description
     * Creates a gateway for the specified gateway identifier and caches it in order to handle postMessage events
     * later in the application lifecycle. This method will fail on subsequent calls in order to prevent two
     * clients from using the same gateway.
     *
     * @param {String} gatewayId The identifier of the gateway.
     * @returns {MessageGateway} Returns the newly created Message Gateway or null.
     */
    createGateway(gatewayId: string): MessageGateway;
    /**
     * allowed if receiving end is frame or [container + (white listed storefront or same origin)]
     */
    
}

/// <reference types="angular-mocks" />



/**
 * @ngdoc service
 * @name smarteditCommonsModule.service:GatewayProxy
 *
 * @description
 * To seamlessly integrate the gateway factory between two services on different frames, you can use a gateway
 * proxy. The gateway proxy service simplifies using the gateway module by providing an API that registers an
 * instance of a service that requires a gateway for communication.
 *
 * This registration process automatically attaches listeners to each of the service's functions (turned into promises), allowing stub
 * instances to forward calls to these functions using an instance of a gateway from {@link
 * smarteditCommonsModule.service:GatewayFactory gatewayFactory}. Any function that has an empty body declared on the service is used
 * as a proxy function. It delegates a publish call to the gateway under the same function name, and wraps the result
 * of the call in a Promise.
 */
export class GatewayProxy {
    
    
    
    
    
    
    
    constructor($log: angular.ILogService, $q: angular.IQService, toPromise: any, isBlank: any, functionsUtils: FunctionsUtils, gatewayFactory: GatewayFactory);
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:GatewayProxy#initForService
     * @methodOf smarteditCommonsModule.service:GatewayProxy
     *
     * @description Mutates the given service into a proxied service.
     * You must provide a unique string gatewayId, in one of 2 ways.<br />
     * 1) Having a gatewayId property on the service provided<br />
     * OR<br />
     * 2) providing a gatewayId as 3rd param of this function<br />
     *
     * @param {any} service Service to mutate into a proxied service.
     * @param {String[]=} methodsSubset An explicit set of methods on which the gatewayProxy will trigger. Otherwise, by default all functions will be proxied. This is particularly useful to avoid inner methods being unnecessarily turned into promises.
     * @param {String=} gatewayId The gateway ID to use internaly for the proxy. If not provided, the service <strong>must<strong> have a gatewayId property.
     */
    initForService<T extends IProxiedService>(service: T, methodsSubset?: string[], gatewayId?: string): void;
    
    
    
}

export * from './GatewayFactory';
export * from './GatewayProxy';
export * from './IProxiedService';
export * from './MessageGateway';



export type CloneableEventHandler<T extends Cloneable> = (eventId: string, eventData?: T) => angular.IPromise<any> | any;
/**
 * @ngdoc service
 * @name smarteditCommonsModule.service:MessageGateway
 *
 * @description
 * The Message Gateway is a 
 * boundaries. The gateway uses the W3C-compliant postMessage as its underlying technology. The benefits of
 * the postMessage are that:
 * <ul>
 *     <li>It works in cross-origin scenarios.</li>
 *     <li>The receiving end can reject messages based on their origins.</li>
 * </ul>
 *
 * The creation of instances is controlled by the {@link smarteditCommonsModule.service:GatewayFactory gatewayFactory}. Only one
 * instance can exist for each gateway ID.
 *
 * @param {String} gatewayId The channel identifier
 * @constructor
 */
export class MessageGateway {
    
    
    
    
    
    
    
    readonly gatewayId: string;
    
    
    
    
    
    
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:MessageGateway#publish
     * @methodOf smarteditCommonsModule.service:MessageGateway
     *
     * @description
     * Publishes a message across the gateway using the postMessage.
     *
     * The gateway's publish method implements promises, which are an AngularJS implementation. To resolve a
     * publish promise, all listener promises on the side of the channel must resolve. If a failure occurs in the
     * chain, the chain is interrupted and the publish promise is rejected.
     *
     * @param {String} eventId Event identifier
     * @param {Object} data Message payload
     * @param {Number} retries The current number of attempts to publish a message. By default it is 0.
     * @param {String=} pk An optional parameter. It is a primary key for the event, which is generated after
     * the first attempt to send a message.
     * @returns {Promise} Promise to resolve
     */
    publish<Tin extends Cloneable, Tout extends Cloneable>(eventId: string, _data: Tin, retries?: number, pk?: string): angular.IPromise<Tout>;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:MessageGateway#subscribe
     * @methodOf smarteditCommonsModule.service:MessageGateway
     *
     * @description
     * Registers a given callback function to the given event ID.
     *
     * @param {String} eventId Event identifier
     * @param {CloneableEventHandler} callback Callback function to be invoked
     * @returns {() => void)} The function to call in order to unsubscribe the event listening
     */
    subscribe<T extends Cloneable>(eventId: string, callback: CloneableEventHandler<T>): () => void;
    processEvent(event: IGatewayPostMessageData): void;
    
    
}

/// <reference types="angular" />
/// <reference types="angular-mocks" />

export const GatewayProxied: (...args: string[]) => ClassDecorator;
export function GatewayProxiedAnnotationFactory(gatewayProxy: GatewayProxy, $log: angular.ILogService): import("smarteditcommons/services/annotationService").ClassAnnotationFactory;

/// <reference types="angular" />
/// <reference types="angular-resource" />

export const OperationContextRegistered: (url: string, operationContext: string | string[]) => ClassDecorator;
export function OperationContextAnnotationFactory($injector: angular.auto.IInjectorService, operationContextService: OperationContextService, OPERATION_CONTEXT: any): import("smarteditcommons/services/annotationService").ClassAnnotationFactory;

/**
 * @ngdoc service
 * @name smarteditCommonsModule.service:OperationContextService
 * @description
 * This service provides the functionality to register a url with its associated operation contexts and also finds operation context given an url.
 */
export class OperationContextService {
    
    
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:OperationContextService#register
     * @methodOf smarteditCommonsModule.service:OperationContextService
     *
     * @description
     * Register a new url with it's associated operationContext.
     *
     * @param {String} url The url that is associated to the operation context.
     * @param {String} operationContext The operation context name that is associated to the given url.
     *
     * @return {Object} operationContextService The operationContextService service
     */
    register(url: string, operationContext: string): this;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:OperationContextService#findOperationContext
     * @methodOf smarteditCommonsModule.service:OperationContextService
     *
     * @description
     * Find the first matching operation context for the given url.
     *
     * @param {String} url The request url.
     *
     * @return {String} operationContext
     */
    findOperationContext(url: string): string;
}


export * from './dependencyInjection/di';
export * from './annotationService';
export * from './cache';
export * from './gateway';
export * from './interfaces';









export * from './rest/rest';







export * from './dragAndDrop';
export * from './storage';




export enum SeAlertServiceType {
    Info = "INFO",
    Success = "SUCCESS",
    Warning = "WARNING",
    Danger = "DANGER"
}
export interface IAlertConfig {
    message?: string;
    type?: SeAlertServiceType;
    messagePlaceholders?: {
        [key: string]: any;
    };
    template?: string;
    templateUrl?: string;
    closeable?: boolean;
    timeout?: number;
}
export interface IAlertService {
    showAlert(alertConf: IAlertConfig | string): void;
    showInfo(alertConf: IAlertConfig | string): void;
    showDanger(alertConf: IAlertConfig | string): void;
    showWarning(alertConf: IAlertConfig | string): void;
    showSuccess(alertConf: IAlertConfig | string): void;
}

export interface IBrowserService {
    getCurrentBrowser(): 'IE' | 'Chrome' | 'Firefox' | 'Edge' | 'Safari' | 'Uknown';
    isIE(): boolean;
    isFF(): boolean;
    isSafari(): boolean;
    getBrowserLocale(): string;
}

/// <reference types="angular" />


/**
 * @ngdoc service
 * @name smarteditServicesModule.service:catalogService
 *
 * @description
 * The Catalog Service fetches catalogs for a specified site or for all sites registered on the hybris platform using
 * REST calls to the cmswebservices Catalog Version Details API.
 */
export class ICatalogService {
    /**
     * @deprecated since 6.4
     *
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#getAllCatalogsGroupedById
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * Fetches a list of content catalog groupings for all sites.
     *
     * @returns {Array} An array of catalog groupings sorted by catalog ID, each of which has a name, a catalog ID, and a list of
     * catalog version descriptors.
     */
    getAllCatalogsGroupedById(): angular.IPromise<ICatalog[][]>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#retrieveUriContext
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * Convenience method to return a full {@link resourceLocationsModule.object:UriContext uriContext} to the invoker through a promise.
     * <br/>if uriContext is provided, it will be returned as such.
     * <br/>if uriContext is not provided, A uriContext will be built from the experience present in {@link  smarteditServicesModule.sharedDataService sharedDataService}.
     * if we fail to find a uriContext in sharedDataService, an exception will be thrown.
     * @param {=Object=} uriContext An optional uriContext that, if provided, is simply returned wrapped in a promise
     *
     * @returns {Object} a {@link resourceLocationsModule.object:UriContext uriContext}
     */
    retrieveUriContext(_uriContext?: IUriContext): angular.IPromise<IUriContext>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#getContentCatalogsForSite
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * Fetches a list of content catalogs for the site that corresponds to the specified site UID.
     *
     * @param {String} siteUID The UID of the site that the catalog versions are to be fetched.
     *
     * @returns {Array} An array of catalog descriptors. Each descriptor provides the following catalog properties:
     * catalog (name), catalogId, and catalog version descriptors.
     */
    getContentCatalogsForSite(siteUID: string): angular.IPromise<IBaseCatalog[]>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#getAllContentCatalogsGroupedById
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * Fetches a list of content catalog groupings for all sites.
     *
     * @returns {Array} An array of catalog groupings sorted by catalog ID, each of which has a name, a catalog ID, and a list of
     * catalog version descriptors.
     */
    getAllContentCatalogsGroupedById(): angular.IPromise<ICatalog[][]>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#getCatalogByVersion
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * Fetches a list of catalogs for the given site UID and a given catalog version.
     *
     * @param {String} siteUID The UID of the site that the catalog versions are to be fetched.
     * @param {String} catalogVersion The version of the catalog that is to be fetched.
     *
     * @returns {Array} An array containing the catalog descriptor (if any). Each descriptor provides the following catalog properties:
     * catalog (name), catalogId, and catalogVersion.
     */
    getCatalogByVersion(siteUID: string, catalogVersionName: string): angular.IPromise<IBaseCatalog[]>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#isContentCatalogVersionNonActive
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * Determines whether the catalog version identified by the given uriContext is a non active one
     * if no uriContext is provided, an attempt will be made to retrieve an experience from {@link smarteditServicesModule.sharedDataService sharedDataService}
     *
     * @param {Object} uriContext the {@link resourceLocationsModule.object:UriContext UriContext}. Optional
     * @returns {Boolean} true if the given catalog version is non active
     */
    isContentCatalogVersionNonActive(_uriContext?: IUriContext): angular.IPromise<boolean>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#getContentCatalogActiveVersion
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * find the version that is flagged as active for the given uriContext
     * if no uriContext is provided, an attempt will be made to retrieve an experience from {@link smarteditServicesModule.sharedDataService sharedDataService}
     *
     * @param {Object} uriContext the {@link resourceLocationsModule.object:UriContext UriContext}. Optional
     * @returns {String} the version name
     */
    getContentCatalogActiveVersion(_uriContext?: IUriContext): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#getActiveContentCatalogVersionByCatalogId
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * Finds the version name that is flagged as active for the given content catalog.
     *
     * @param {String} contentCatalogId The UID of content catalog for which to retrieve its active catalog version name.
     * @returns {String} the version name
     */
    getActiveContentCatalogVersionByCatalogId(contentCatalogId: string): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#getDefaultSiteForContentCatalog
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * Finds the ID of the default site configured for the provided content catalog.
     *
     * @param {String} contentCatalogId The UID of content catalog for which to retrieve its default site ID.
     * @returns {String} the ID of the default site found.
     */
    getDefaultSiteForContentCatalog(contentCatalogId: string): angular.IPromise<ISite>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#getContentCatalogVersion
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * Finds the catalog version given an uriContext object.
     *
     * @param {Object} uriContext  An object that represents the current context, containing information about the site.
     * @returns {angular.IPromise<IBaseCatalogVersion>} A promise that resolves to the catalog version descriptor found.
     */
    getContentCatalogVersion(uriContext: IUriContext): angular.IPromise<IBaseCatalogVersion>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#getCatalogVersionByUuid
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * Finds the catalog version descriptor identified by the provided UUID. An exception is thrown if no
     * match is found.
     *
     * @param {String} catalogVersionUuid The UID of the catalog version descriptor to find.
     * @param {String=} siteId the ID of the site where to perform the search. If no ID is provided, the search will
     * be performed on all permitted sites.
     * @returns {Promise} A promise that resolves to the catalog version descriptor found.
     *
     */
    getCatalogVersionByUuid(catalogVersionUuid: string, siteId?: string): angular.IPromise<ICatalogVersion>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#getCatalogVersionUUid
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * Finds the catalog version UUID given an optional urlContext object. The current catalog version UUID from the active experience selector is returned, if the URL is not present in the call.
     *
     * @param {Object} urlContext An object that represents the current context, containing information about the site.
     * @returns {Promise<String>} A promise that resolves to the catalog version uuid.
     *
     */
    getCatalogVersionUUid(_uriContext?: IUriContext): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#getProductCatalogsForSite
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * Fetches a list of product catalogs for the site that corresponds to the specified site UID.
     *
     * @param {String} siteUID The UID of the site that the catalog versions are to be fetched.
     *
     * @returns {Array} An array of catalog descriptors. Each descriptor provides the following catalog properties:
     * catalog (name), catalogId, and catalog version descriptors.
     */
    getProductCatalogsForSite(siteUID: string): angular.IPromise<IBaseCatalog[]>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#getActiveProductCatalogVersionByCatalogId
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * Finds the version name that is flagged as active for the given product catalog.
     *
     * @param {String} productCatalogId The UID of product catalog for which to retrieve its active catalog version name.
     * @returns {String} the version name
     */
    getActiveProductCatalogVersionByCatalogId(productCatalogId: string): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogService#returnActiveCatalogVersionUIDs
     * @methodOf smarteditServicesModule.service:catalogService
     *
     * @description
     * Fetches all the active catalog version uuid's for a provided array of catalogs.
     *
     * @param {Array} An array of catalogs objects. Each catalog object must have a versions array.
     * @returns {Array} An array of catalog version uuid's
     */
    returnActiveCatalogVersionUIDs(catalogs: ICatalog[]): string[];
}



/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IContextualMenuButton
 * @description
 * payload passed to ContextualMenuService#addItems, to describe a contextual menu button
 */
export interface IContextualMenuButton extends IFeature, IPrioritized {
    /**
     * @ngdoc object
     * @name smarteditServicesModule.object:action
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {Object} action The action to be performed when clicking the menu item.
     * Action is an object that must contain exactly one of callback | callbacks | template | templateUrl<br />
     */
    action?: {
        /**
         * @ngdoc property
         * @name smarteditServicesModule.property:template
         * @propertyOf smarteditServicesModule.object:action
         * @description {string} template is an html string that will displayed below the menu item when the item is clicked.
         */
        template?: string;
        /**
         * @ngdoc property
         * @name smarteditServicesModule.property:templateUrl
         * @propertyOf smarteditServicesModule.object:action
         * @description {string} templateUrl is the same as template but instead of passing a string, pass a url to an html file.
         */
        templateUrl?: string;
        /**
         * @ngdoc property
         * @name smarteditServicesModule.property:callbacks
         * @propertyOf smarteditServicesModule.object:action
         * @description {object} map of DOM events occuring on the contextual menu button and callbacks to be invoked when they occur
         */
        callbacks?: TypedMap<(configuration?: IContextualMenuConfiguration, $event?: Event) => void>;
        /**
         * @ngdoc method
         * @name callback
         * @methodOf smarteditServicesModule.object:action
         * @description {Function} callback A function executed on clicking of the menu item. It is invoked with the component specific {@link IContextualMenuConfiguration IContextualMenuConfiguration}
         * @param {IContextualMenuConfiguration=} configuration the smartedit component specific {@link smarteditServicesModule.interface:IContextualMenuConfiguration IContextualMenuConfiguration}
         * @param {$event=} $event the yjQuery event triggering the callback
         */
        callback?(configuration?: IContextualMenuConfiguration, $event?: Event): void;
    };
    /**
     * @ngdoc property
     * @name i18nKey
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {String=} i18nKey i18nKey Is the message key of the contextual menu item to be translated.
     */
    i18nKey?: string;
    /**
     * @ngdoc property
     * @name displayClass
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {String=} displayClass Contains the CSS classes used to style the contextual menu item
     */
    displayClass?: string;
    /**
     * @ngdoc property
     * @name displayIconClass
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {String=} displayIconClass Contains the CSS classes used to style the non-idle icon of the contextual menu item to be displayed.
     */
    displayIconClass?: string;
    /**
     * @ngdoc property
     * @name displaySmallIconClass
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {String=} displaySmallIconClass displaySmallIconClass Contains the location of the smaller version of the icon to be displayed when the menu item is part of the More... menu options.
     */
    displaySmallIconClass?: string;
    /**
     * @ngdoc property
     * @name iconIdle
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {String=} iconIdle iconIdle Contains the location of the idle icon of the contextual menu item to be displayed.
     */
    iconIdle?: string;
    /**
     * @ngdoc property
     * @name iconNonIdle
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {String=} iconNonIdle iconNonIdle Contains the location of the non-idle icon of the contextual menu item to be displayed.
     */
    iconNonIdle?: string;
    /**
     * @ngdoc property
     * @name templateUrl
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description
     * deprecated since 6.5, see {@link smarteditServicesModule.object:action action}
     * @deprecated since 6.5, see {@link smarteditServicesModule.object:action action}
     */
    templateUrl?: string;
    /**
     * @ngdoc property
     * @name regexpKeys
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {String} regexpKeys array of regular expressions matching component types eligible for this button
     */
    regexpKeys: string[];
    /**
     * @ngdoc property
     * @name callbacks
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description
     * deprecated since 6.7, see {@link smarteditServicesModule.object:action action}
     * @deprecated since 6.7, see {@link smarteditServicesModule.object:action action}
     */
    callbacks?: TypedMap<(configuration?: IContextualMenuConfiguration, $event?: Event) => void>;
    /**
     * @ngdoc method
     * @name condition
     * @methodOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {Function} contextualMenuItemsMap.condition condition Is an optional entry that holds the condition function required to activate the menu item. It is invoked with a {@link smarteditServicesModule.interface:IContextualMenuConfiguration IContextualMenuConfiguration} payload
     */
    condition?(configuration: IContextualMenuConfiguration): boolean | angular.IPromise<boolean>;
    /**
     * @ngdoc method
     * @name callback
     * @methodOf smarteditServicesModule.interface:IContextualMenuButton
     * @description
     * deprecated since 6.7, see {@link smarteditServicesModule.object:action action}
     * @deprecated since 6.7, see {@link smarteditServicesModule.object:action action}
     */
    callback?(configuration?: IContextualMenuConfiguration, $event?: Event): void;
}

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IContextualMenuConfiguration
 * @description
 * The smartedit component specific configuration being passed to contextualMenuService
 * to retrieve the appropriate list of {@link smarteditServicesModule.interface:IContextualMenuButton IContextualMenuButton}
 * and being passed to condition and callbak function of {@link smarteditServicesModule.interface:IContextualMenuButton IContextualMenuButton}
 */
export interface ComponentAttributes {
    [index: string]: string;
    smarteditCatalogVersionUuid: string;
    smarteditComponentId: string;
    smarteditComponentType: string;
    smarteditComponentUuid: string;
    smarteditElementUuid: string;
}
export interface IContextualMenuConfiguration {
    /**
     * @param {Map<ComponentAttributes>} componentAttributes the map of all attributes prefixed with smartedit- collected on the DOM element
     */
    componentAttributes: ComponentAttributes;
    /**
     * @param {String} componentType The type code of the selected component.
     */
    componentType: string;
    /**
     * @param {String} componentId The ID of the selected component.
     */
    componentId: string;
    /**
     * containerType The type code of the container of the component if applicable, this is optional.
     */
    containerType?: string;
    /**
     * @param {String} containerId The ID of the container of the component if applicable, this is optional.
     */
    containerId?: string;
    /**
     * @param {String} slotId the smarteditComponent id of the slot containing the component, null if a slot itself
     */
    slotId: string;
    /**
     * @param {String} slotUuid the UUID id of the slot containing the component, null if a slot itself
     */
    slotUuid: string;
    /**
     * @param {Number} iLeftBtns The number of visible contextual menu items for a specified component.
     */
    iLeftBtns: number;
    /**
     * @param {number} element The DOM element of selected component
     */
    element: HTMLElement;
    /**
     * @param {boolean} isComponentHidden hiiden state of the component
     */
    isComponentHidden: boolean;
}

/// <reference types="angular" />

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IDecorator
 *
 * @description
 * Interface for IDecorator and it acts as a payload passed to addDecorator method of featureService method to register a decorator as a feature.
 */
export interface IDecorator extends IFeature {
    displayCondition?(componentType: string, componentId: string): ng.IPromise<boolean>;
}



/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IExperience
 * @description
 * IExperience - Interface for experience information
 */
export interface IExperience extends Payload {
    catalogDescriptor: IExperienceCatalogDescriptor;
    siteDescriptor: ISite;
    productCatalogVersions: IExperienceCatalogVersion[];
    time: string;
    languageDescriptor?: ILanguage;
    pageId?: string;
    pageContext?: IExperiencePageContext;
}
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IExperienceCatalogDescriptor
 * @description
 * IExperienceCatalogDescriptor interface acts as a pointer to catalog and catalogVersion of the experience
 */
export interface IExperienceCatalogDescriptor extends Payload {
    active: boolean;
    catalogId: string;
    catalogVersion: string;
    catalogVersionUuid: string;
    name: TypedMap<string>;
    siteId: string;
}
export interface IExperienceCatalogVersion extends Payload {
    active: boolean;
    catalog: string;
    catalogName: TypedMap<string>;
    catalogVersion: string;
    uuid: string;
}
export interface IExperiencePageContext extends Payload {
    catalogId: string;
    catalogName: TypedMap<string>;
    catalogVersion: string;
    catalogVersionUuid: string;
    siteId: string;
    active: boolean;
}
export interface IDefaultExperienceParams {
    siteId: string;
    catalogId: string;
    catalogVersion: string;
    pageId?: string;
}
export interface IExperienceParams extends IDefaultExperienceParams {
    time?: string;
    productCatalogVersions?: string[];
    language?: string;
}

/// <reference types="angular" />



/**
 * @ngdoc service
 * @name smarteditServicesModule.service:ExperienceService
 *
 * @description
 * ExperienceService deals with building experience objects given a context.
 */
export class IExperienceService {
    
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ExperienceService#getCurrentExperience
     * @methodOf smarteditServicesModule.service:ExperienceService
     *
     * @description
     * Retrieves the active experience.
     *
     * @returns {IExperience} an {@link smarteditServicesModule.interface:IExperience experience}
     */
    getCurrentExperience(): angular.IPromise<IExperience>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ExperienceService#setCurrentExperience
     * @methodOf smarteditServicesModule.service:ExperienceService
     *
     * @description
     * Stores a given experience as current experience.
     * Invoking this method ensures that a hard refresh of the application will preserve the experience.
     *
     * @returns {angular.IPromise<IExperience>} a promise returning the experience
     */
    setCurrentExperience(experience: IExperience): angular.IPromise<IExperience>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ExperienceService#hasCatalogVersionChanged
     * @methodOf smarteditServicesModule.service:ExperienceService
     *
     * @description
     * Determines whether the catalog version has changed between the previous and current experience
     *
     * @returns {angular.IPromise<boolean>} a promise returning whether thta catalog version has changed
     */
    hasCatalogVersionChanged(): angular.IPromise<boolean>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ExperienceService#buildRefreshedPreviewUrl
     * @methodOf smarteditServicesModule.service:ExperienceService
     *
     * @description
     * Retrieves the active experience, creates a new preview ticket and returns a new preview url with an updated
     * previewTicketId query param
     *
     * @returns {angular.IPromise<string>} an url containing the new previewTicketId
     */
    buildRefreshedPreviewUrl(): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ExperienceService#updateExperience
     * @methodOf smarteditServicesModule.service:ExperienceService
     *
     * @description
     * Retrieves the active experience, merges it with a new experience, creates a new preview ticket and reloads the
     * preview within the iframeManagerService
     *
     * @param {Payload=} newExperience The object containing new attributes to be merged with the current experience
     *
     * @returns {angular.IPromise<IExperience>} An promise of the updated experience
     */
    updateExperience(newExperience?: Payload): angular.IPromise<IExperience>;
}

export interface InternalFeature {
    /**
     * @ngdoc property
     * @name key
     * @propertyOf smarteditServicesModule.interface:IFeature
     * @description The feature (could be IDecorator | IToolbarItem | IContextualMenuButton) key defined in the API
     */
    key: string;
    /**
     * @ngdoc property
     * @name nameI18nKey
     * @propertyOf smarteditServicesModule.interface:IFeature
     * @description The i18n key that stores the feature name to be translated.
     */
    nameI18nKey: string;
    /**
     * @ngdoc property
     * @name descriptionI18nKey
     * @propertyOf smarteditServicesModule.interface:IFeature
     * @description The i18n key that stores the feature description to be translated. The description is used as a tooltip in the web application. This is an optional parameter.
     */
    descriptionI18nKey?: string;
    /**
     * @ngdoc property
     * @name permissions
     * @propertyOf smarteditServicesModule.interface:IFeature
     * @description The list of permissions required to enable the feature.
     */
    permissions?: string[];
}
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IFeature
 *
 * @description
 * IFeature - Interface for feature configuration DTO in FeatureService
 */
export interface IFeature extends InternalFeature {
    /**
     * @ngdoc property
     * @name enablingCallback
     * @propertyOf smarteditServicesModule.interface:IFeature
     * @description The callback to be called when feature is enabled.
     */
    enablingCallback?: () => void;
    /**
     * @ngdoc property
     * @name disablingCallback
     * @propertyOf smarteditServicesModule.interface:IFeature
     * @description The callback to be called when feature is disbled.
     */
    disablingCallback?: () => void;
}

/// <reference types="angular" />

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IFeatureService
 *
 * @description
 * The interface stipulates how to register features in the SmartEdit application and the SmartEdit container.
 * The SmartEdit implementation stores two instances of the interface across the {@link smarteditCommonsModule.service:GatewayFactory gateway}: one for the SmartEdit application and one for the SmartEdit container.
 */
export class IFeatureService {
    
    
    
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IFeatureService#register
     * @methodOf smarteditServicesModule.interface:IFeatureService
     * @description
     * This method registers a feature.
     * When an end user selects a perspective, all the features that are bound to the perspective
     * will be enabled when their respective enablingCallback functions are invoked
     * and all the features that are not bound to the perspective will be disabled when their respective disablingCallback functions are invoked.
     * The SmartEdit application and the SmartEdit container hold/store an instance of the implementation because callbacks cannot cross the gateway as they are functions.
     *
     * this method is meant to register a feature (identified by a key).
     * When a perspective (registered through {@link smarteditServicesModule.interface:IPerspectiveService#methods_register IPerspectiveService.register}) is selected, all its bound features will be enabled by invocation of their respective enablingCallback functions
     * and any feature not bound to it will be disabled by invocation of its disablingCallback function.
     * Both SmartEdit and SmartEditContainer will hold a concrete implementation since Callbacks, being functions, cannot cross the gateway.
     * The function will keep a frame bound reference on a full feature in order to be able to invoke its callbacks when needed.
     *
     * @param {IContextualMenuButton | IDecorator | IToolbarItem} configuration of a {@link smarteditServicesModule.interface:IContextualMenuButton IContextualMenuButton} or
     * {@link smarteditServicesModule.interface:IDecorator IDecorator} or {@link smarteditServicesModule.interface:IToolbarItem IToolbarItem}
     *
     * @return {angular.IPromise<void>} An empty promise
     */
    register(configuration: IFeature): angular.IPromise<void>;
    enable(key: string): void;
    disable(key: string): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IFeatureService#getFeatureProperty
     * @methodOf smarteditServicesModule.interface:IFeatureService
     * @description
     * Returns a feature property
     *
     * @param {String} featureKey the key property value of the feature
     * @param {String} propertyName name of the property
     *
     * @return {angular.IPromise<string | string[] | (() => void)>} returns promise of property value or null if property does not exist
     */
    getFeatureProperty(featureKey: string, propertyName: keyof IFeature): angular.IPromise<string | string[] | (() => void)>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IFeatureService#addToolbarItem
     * @methodOf smarteditServicesModule.interface:IFeatureService
     *
     * @description
     * This method registers toolbar items as features. It is a wrapper around {@link smarteditServicesModule.interface:IFeatureService#methods_register register}.
     *
     * @param {IToolbarItem} configuration The {@link smarteditServicesModule.interface:IToolbarItem configuration} that represents the toolbar action item to be registered.
     *
     * @return {angular.IPromise<void>} An empty promise
     */
    addToolbarItem(toolbar: IToolbarItem): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IFeatureService#addDecorator
     * @methodOf smarteditServicesModule.interface:IFeatureService
     *
     * @description
     * this method registers decorator and delegates to the
     *  {@link decoratorServiceModule.service:decoratorService#methods_enable enable}
     *  {@link decoratorServiceModule.service:decoratorService#methods_disable disable} methods of
     *  {@link decoratorServiceModule.service:decoratorService decoratorService}.
     * This method is not a wrapper around {@link decoratorServiceModule.service:decoratorService#addMappings decoratorService.addMappings}:
     * From a feature stand point, we deal with decorators, not their mappings to SmartEdit components.
     * We still need to have a separate invocation of {@link decoratorServiceModule.service:decoratorService#addMappings decoratorService.addMappings}
     * @param {IDecorator} configuration The {@link smarteditServicesModule.interface:IDecorator configuration} that represents the decorator to be registered.
     * @return {angular.IPromise<void>} An empty promise
     */
    addDecorator(decorator: IDecorator): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IFeatureService#addContextualMenuButton
     * @methodOf smarteditServicesModule.interface:IFeatureService
     *
     * @description
     * This method registers contextual menu buttons. It is a wrapper around {@link smarteditServicesModule.ContextualMenuService#methods_addItems contextualMenuService.addItems}.
     *
     * @param {IContextualMenuButton} btn The {@link smarteditServicesModule.interface:IContextualMenuButton btn} that represents the feature to be registered.
     *
     * @return {angular.IPromise<void>} An empty promise
     */
    addContextualMenuButton(btn: IContextualMenuButton): angular.IPromise<void>;
    
    
    /**
     * This method registers a feature, identified by a unique key, across the {@link smarteditCommonsModule.service:GatewayFactory gateway}.
     * It is a simplified version of the register method, from which callbacks have been removed.
     */
    
    
}

/// <reference types="angular" />
export interface IModalService {
    open: (config: {
        title?: string;
        titleSuffix?: string;
        cssClasses?: string;
        buttons?: any[];
        size?: string;
        templateInline?: string;
        templateUrl?: string;
        template?: string;
        animation?: boolean;
        controller: angular.IControllerConstructor;
    }) => angular.IPromise<any>;
    close: (data?: any) => void;
    dismiss: (data?: any) => void;
}



export * from './ICatalogService';
export * from './IConfiguration';



export * from './IExperience';



















export * from './IPermissionService';
export * from './IResizeListener';
export * from './IPositionRegistry';
export * from './IURIBuilder';

/// <reference types="angular" />
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface: IBound
 * @description
 * Interface for mouse bounds
 */
export interface IBound {
    x: number;
    y: number;
    width: number;
    height: number;
}
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:INotificationMouseLeaveDetectionService
 *
 * @description
 * The interface defines the methods required to detect when the mouse leaves the notification panel
 * in the SmartEdit application and in the SmartEdit container.
 *
 * It is solely meant to be used with the notificationService.
 */
export class INotificationMouseLeaveDetectionService {
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:INotificationMouseLeaveDetectionService#startDetection
     * @methodOf smarteditServicesModule.interface:INotificationMouseLeaveDetectionService
     *
     * @description
     * This method starts tracking the movement of the mouse pointer in order to detect when it
     * leaves the notification panel.
     *
     * The innerBounds parameter is considered optional. If it is not provided, it will not be
     * validated and detection will only be started in the SmartEdit container.
     *
     * Here is an example of a bounds object:
     *
     * {
     *     x: 100,
     *     y: 100,
     *     width: 200,
     *     height: 50
     * }
     *
     * This method will throw an error if:
     *     - the bounds parameter is not provided
     *     - a bounds object does not contain the X coordinate
     *     - a bounds object does not contain the Y coordinate
     *     - a bounds object does not contain the width dimension
     *     - a bounds object does not contain the height dimension
     */
    startDetection(outerBounds: IBound, innerBounds: IBound, callback: () => any): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:INotificationMouseLeaveDetectionService#stopDetection
     * @methodOf smarteditServicesModule.interface:INotificationMouseLeaveDetectionService
     *
     * @description
     * This method stops tracking the movement of the mouse pointer.
     */
    stopDetection(): angular.IPromise<void>;
    /**
     * This method is used to start tracking the movement of the mouse pointer within the iFrame.
     */
    
    /**
     * This method is used to stop tracking the movement of the mouse pointer within the iFrame.
     */
    
    /**
     * This method is used to call the callback function when it is detected from within the iFrame that
     * the mouse left the notification panel
     */
    
    /**
     * This method is called for each mouse movement. It evaluates whether or not the
     * mouse pointer is in the notification panel. If it isn't, it calls the onMouseLeave.
     */
    
    /**
     * This method gets bounds
     */
    
    /**
     * This method gets callback
     */
    
    /**
     * This method is triggered when the service has detected that the mouse left the
     * notification panel. It will execute the callback function and stop detection.
     */
    
}


/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:INotificationConfiguration
 *
 * @description
 * Interface for Notification Configuration
 */
export interface INotificationConfiguration {
    /**
     * @ngdoc property
     * @name id
     * @propertyOf smarteditServicesModule.interface:INotificationConfiguration
     * @description The notification's unique identifier
     */
    id: string;
    /**
     * @ngdoc property
     * @name template
     * @propertyOf smarteditServicesModule.interface:INotificationConfiguration
     * @description The notification's HTML template. Either template or templateUrl should be present but not both.
     */
    template?: string;
    /**
     * @ngdoc property
     * @name template
     * @propertyOf smarteditServicesModule.interface:INotificationConfiguration
     * @description The notification's template URL. Either template or templateUrl should be present but not both.
     */
    templateUrl?: string;
}
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:INotificationService
 *
 * @description
 * INotificationService provides a service to display visual cues to inform
 * the user of the state of the application in the container or the iFramed application.
 * The interface defines the methods required to manage notifications that are to be displayed to the user.
 */
export class INotificationService {
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:INotificationService#pushNotification
     * @methodOf smarteditServicesModule.interface:INotificationService
     *
     * @description
     * This method creates a new notification based on the given configuration and
     * adds it to the top of the list.
     *
     * The configuration must contain either a template or template URL, but not both.
     *
     * @param {Object} configuration The notification's configuration {@link smarteditServicesModule.interface:INotificationConfiguration INotificationConfiguration}
     *
     * @throws An error if no configuration is given.
     * @throws An error if the configuration does not contain a unique identifier.
     * @throws An error if the configuration's unique identifier is an empty string.
     * @throws An error if the configuration does not contain a template or templateUrl.
     * @throws An error if the configuration contains both a template and template Url.
     */
    pushNotification(configuration: INotificationConfiguration): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:INotificationService#removeNotification
     * @methodOf smarteditServicesModule.interface:INotificationService
     *
     * @description
     * This method removes the notification with the given ID from the list.
     *
     * @param {String} notificationId The notification's unique identifier.
     */
    removeNotification(notificationId: string): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:INotificationService#removeAllNotifications
     * @methodOf smarteditServicesModule.interface:INotificationService
     *
     * @description
     * This method removes all notifications.
     */
    removeAllNotifications(): angular.IPromise<void>;
}


/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IPageInfoService
 *
 * @description
 * The IPageInfoService provides information about the storefront page currently loaded in the iFrame.
 */
export class IPageInfoService {
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPageInfoService#getPageUID
     * @methodOf smarteditServicesModule.interface:IPageInfoService
     *
     * @description
     * This extracts the pageUID of the storefront page loaded in the smartedit iframe.
     *
     * @return {angular.IPromise<string>} A promise resolving to a string matching the page's ID
     */
    getPageUID(): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPageInfoService#getPageUUID
     * @methodOf smarteditServicesModule.interface:IPageInfoService
     *
     * @description
     * This extracts the pageUUID of the storefront page loaded in the smartedit iframe.
     * The UUID is different from the UID in that it is an encoding of uid and catalog version combined
     *
     * @return {angular.IPromise<string>} A promise resolving to the page's UUID
     */
    getPageUUID(): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPageInfoService#getCatalogVersionUUIDFromPage
     * @methodOf smarteditServicesModule.interface:IPageInfoService
     *
     * @description
     * This extracts the catalogVersionUUID of the storefront page loaded in the smartedit iframe.
     * The UUID is different from the UID in that it is an encoding of uid and catalog version combined
     *
     * @return {angular.IPromise<string>} A promise resolving to the page's UUID
     */
    getCatalogVersionUUIDFromPage(): angular.IPromise<string>;
}

/// <reference types="angular" />

export interface Rule {
    names: string[];
    verify: (permissionObjects?: PermissionContext[]) => angular.IPromise<boolean>;
}
export interface Permission {
    aliases: string[];
    rules: string[];
}
export interface MultiNamePermissionContext {
    names: string[];
    context?: TypedMap<any>;
}
export interface PermissionContext {
    name: string;
    context?: TypedMap<any>;
}
/**
 * @ngdoc service
 * @name smarteditCommonsModule.service:PermissionServiceInterface
 *
 * @description
 * The permission service is used to check if a user has been granted certain permissions.
 *
 * It is configured with rules and permissions. A rule is used to execute some logic to determine whether or not
 * the permission should be granted. A permission references a list of rules. In order for a permission to be
 * granted, each rule must be executed successfully and return true.
 */
export class IPermissionService {
    ruleVerifyFunctions: TypedMap<{
        verify: (obj: any) => angular.IPromise<boolean>;
    }>;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:PermissionServiceInterface#clearCache
     * @methodOf smarteditCommonsModule.service:PermissionServiceInterface
     *
     * @description
     * This method clears all cached results in the rules' caches.
     */
    clearCache(): void;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:PermissionServiceInterface#getPermission
     * @methodOf smarteditCommonsModule.service:PermissionServiceInterface
     *
     * @description
     * This method returns the registered permission that contains the given name in its
     * array of names.
     *
     * @param {String} permissionName The name of the permission to lookup.
     *
     * @returns {Object} rule The permission with the given name, undefined otherwise.
     */
    getPermission(permission: string): Permission;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:PermissionServiceInterface#isPermitted
     * @methodOf smarteditCommonsModule.service:PermissionServiceInterface
     *
     * @description
     * This method checks if a user has been granted certain permissions.
     *
     * It takes an array of permission objects structured as follows:
     *
     * {
     *     names: ["permission.aliases"],
     *     context: {
     *         data: "required to check a permission"
     *     }
     * }
     *
     * @param {Object[]} permissions A list of permission objects.
     *
     * @returns {IPromise} A promise that resolves to true if permission is granted, rejects to false if it isn't and rejects on error.
     */
    isPermitted(permissions: MultiNamePermissionContext[]): angular.IPromise<boolean>;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:PermissionServiceInterface#registerPermission
     * @methodOf smarteditCommonsModule.service:PermissionServiceInterface
     *
     * @description
     * This method registers a permission.
     *
     * A permission is defined by a set of aliases and rules. It is verified by its set of rules.
     * The set of aliases is there for convenience, as there may be different permissions
     * that use the same set of rules to be verified. The permission aliases property
     * will resolve if any one alias is in the aliases' array. Calling {@link smarteditCommonsModule.service:PermissionServiceInterface#isPermitted}
     * with any of these aliases will use the same permission object, therefore the same
     * combination of rules to check if the user has the appropriate clearance. This reduces the
     * number of permissions you need to register.
     *
     * @param {Object} configuration The configuration of the permission to register.
     * @param {String[]} configuration.aliases The list of aliases associated to the permission. A permission alias must be prefixed by at least one
     * namespace followed by a "." character to be valid. i.e. "se.fake.permission"
     * @param {String[]} configuration.rules The list of the names of the rules used to verify.
     *
     * @throws Will throw an error if the permission has no aliases array
     * @throws Will throw an error if the permission's aliases array is empty
     * @throws Will throw an error if the permission has no rules array
     * @throws Will throw an error if the permission's rule aliases array is empty
     * @throws Will throw an error if a permission is already registered with a common entry in its array of aliases
     * @throws Will throw an error if one of the permission's aliases is not name spaced
     * @throws Will throw an error if no rule is registered with on of the permission's rule names
     */
    registerPermission(permission: Permission): void;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:PermissionServiceInterface#registerRule
     * @methodOf smarteditCommonsModule.service:PermissionServiceInterface
     *
     * @description
     * This method registers a rule. These rules can be used by registering permissions that
     * use them to verify if a user has the appropriate clearance.
     *
     * To avoid accidentally overriding the default rule, an error is thrown when attempting
     * to register a rule with the {@link smarteditServicesModule.object:DEFAULT_RULE_NAME
     * default rule name}.
     *
     * To register the default rule, see {@link smarteditCommonsModule.service:PermissionServiceInterface#registerDefaultRule}.
     *
     * @param {Object} ruleConfiguration The configuration of the rule to register.
     * @param {String[]} ruleConfiguration.names The list of names associated to the rule.
     * @param {Function} ruleConfiguration.verify The verification function of the rule. It must return a promise that responds with true, false, or an error.
     *
     * @throws Will throw an error if the list of rule names contains the reserved {@link smarteditServicesModule.object:DEFAULT_RULE_NAME default rule name}.
     * @throws Will throw an error if the rule has no names array.
     * @throws Will throw an error if the rule's names array is empty.
     * @throws Will throw an error if the rule has no verify function.
     * @throws Will throw an error if the rule's verify parameter is not a function.
     * @throws Will throw an error if a rule is already registered with a common entry in its names array
     */
    registerRule(ruleConfiguration: Rule): void;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:PermissionServiceInterface#registerDefaultRule
     * @methodOf smarteditCommonsModule.service:PermissionServiceInterface
     *
     * @description
     * This method registers the default rule.
     *
     * The default rule is used when no permission is found for a given permission name when
     * {@link smarteditCommonsModule.service:PermissionServiceInterface#isPermitted} is called.
     *
     * @param {Object} ruleConfiguration The configuration of the default rule.
     * @param {String[]} ruleConfiguration.names The list of names associated to the default rule (must contain {@link smarteditServicesModule.object:DEFAULT_RULE_NAME}).
     * @param {Function} ruleConfiguration.verify The verification function of the default rule.
     *
     * @throws Will throw an error if the default rule's names does not contain {@link smarteditServicesModule.object:DEFAULT_RULE_NAME}
     * @throws Will throw an error if the default rule has no names array.
     * @throws Will throw an error if the default rule's names array is empty.
     * @throws Will throw an error if the default rule has no verify function.
     * @throws Will throw an error if the default rule's verify parameter is not a function.
     * @throws Will throw an error if a rule is already registered with a common entry in its names array
     */
    registerDefaultRule(ruleConfiguration: Rule): void;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:PermissionServiceInterface#unregisterDefaultRule
     * @methodOf smarteditCommonsModule.service:PermissionServiceInterface
     *
     * @description
     * This method un-registers the default rule.
     */
    unregisterDefaultRule(): void;
    
    
}




/**
 * @name smarteditServicesModule.interface:IPreviewService
 *
 * @description
 *
 * Interface for previewService.
 *
 * This service is for managing the storefront preview ticket and is proxied across the gateway. (implements)
 *
 */
export class IPreviewService {
    
    constructor(urlUtils: UrlUtils);
    /**
     * @name smarteditServicesModule.interface:IPreviewService#createPreview
     * @methodOf smarteditServicesModule.interface:IPreviewService
     *
     * @description
     * This method will create a new previewTicket for the given experience, using the preview API
     * <br />
     * This method does *NOT* update the current experience.
     *
     * @param {Object} previewData Data representing storefront preview
     *
     * @returns {Object} A {@link smarteditServicesModule.interface:IPreview IPreviewResponse} object
     */
    createPreview(previewData: IPreviewData): angular.IPromise<IPreviewResponse>;
    /**
     * @name smarteditServicesModule.interface:IPreviewService#getResourcePathFromPreviewUrl
     * @methodOf smarteditServicesModule.interface:IPreviewService
     *
     * @description
     * This method will preduce a resourcePath from a given preview url
     * <br />
     * This method does *NOT* update the current experience.
     *
     * @param {Object} previewUrl A URL for a storefornt with preview
     *
     * @returns {Object} A {@link smarteditServicesModule.interface:IPreview IPreviewResponse} object
     */
    getResourcePathFromPreviewUrl(previewUrl: string): angular.IPromise<string>;
    /**
     * @name smarteditServicesModule.interface:IPreviewService#updateUrlWithNewPreviewTicketId
     * @methodOf smarteditServicesModule.interface:IPreviewService
     *
     * @description
     * This method will create a new preview ticket, and return the given url with an updated previewTicketId query param
     * <br />
     * This method does *NOT* update the current experience.
     *
     * @param {string} storefrontUrl Existing storefront url
     * @param {Object} previewData JSON representing storefront previewData (catalog, catalaog vesion, etc...)
     *
     * @returns {string} A new string with storefrontUrl having the new ticket ID inside
     */
    updateUrlWithNewPreviewTicketId(storefrontUrl: string, previewData: IPreviewData): angular.IPromise<string>;
}

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IPrioritized
 * @description
 * Interface of entities aimed at being sorted by priority
 */
export interface IPrioritized {
    /**
     * @ngdoc method
     * @name number
     * @methodOf smarteditServicesModule.interface:IPrioritized
     * @description priority an optional number ranging from 0 to 1000 used for sorting
     */
    priority?: number;
}


export interface IReflectable<T> {
    setMethod?(name: string, methodInstance: (...params: any[]) => (angular.IPromise<void | T> | angular.IPromise<T[]>)): void;
    getMethodForVoid?(name: string): (...params: any[]) => angular.IPromise<void>;
    getMethodForSingleInstance?(name: string): (...params: any[]) => angular.IPromise<T>;
    getMethodForArray?(name: string): (...params: any[]) => angular.IPromise<T[]>;
}



/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:ISessionService
 * @description
 * The ISessionService provides information related to the current session
 * and the authenticated user (including a user readable and writeable languages).
 */
export class ISessionService {
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:ISessionService#getCurrentUsername
     * @methodOf smarteditServicesModule.interface:ISessionService
     *
     * @description
     * Returns the username, previously mentioned as "principalUID",
     * associated to the authenticated user.
     *
     * @returns {angular.IPromise<string>} A promise resolving to the username,
     * previously mentioned as "principalUID", associated to the
     * authenticated user.
     */
    getCurrentUsername(): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:ISessionService#getCurrentUserDisplayName
     * @methodOf smarteditServicesModule.interface:ISessionService
     *
     * @description
     * Returns the displayed name associated to the authenticated user.
     *
     * @returns {angular.IPromise<string>} A promise resolving to the displayed name
     * associated to the authenticated user.
     */
    getCurrentUserDisplayName(): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:ISessionService#getCurrentUser
     * @methodOf smarteditServicesModule.interface:ISessionService
     *
     * @description
     * Returns the data of the current authenticated user.
     * Also note that as part of the User object returned by this method contains
     * the list of readable and writeable languages available to the user.
     *
     * @returns {angular.IPromise<User>} A promise resolving to the data of the current
     * authenticated user.
     */
    getCurrentUser(): angular.IPromise<User>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:ISessionService#hasUserChanged
     * @methodOf smarteditServicesModule.interface:ISessionService
     *
     * @description
     * Returns boolean indicating whether the current user is different from
     * the last authenticated one.
     *
     * @returns {angular.IPromise<boolean>} Boolean indicating whether the current user is
     * different from the last authenticated one.
     */
    hasUserChanged(): angular.IPromise<boolean>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:ISessionService#resetCurrentUserData
     * @methodOf smarteditServicesModule.interface:ISessionService
     *
     * @description
     * Reset all data associated to the authenticated user.
     * to the authenticated user.
     *
     * @return {angular.IPromise<void>} returns an empty promise.
     */
    resetCurrentUserData(): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:ISessionService#setCurrentUsername
     * @methodOf smarteditServicesModule.interface:ISessionService
     *
     * @description
     * Set the username, previously mentioned as "principalUID", associated
     * to the authenticated user.
     *
     * @param {String} currentUsername Username, previously mentioned as
     * "principalUID", associated to the authenticated user.
     *
     * @return {angular.IPromise<void>} returns an empty promise.
     */
    setCurrentUsername(username: string): angular.IPromise<void>;
}



/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:ISharedDataService
 *
 * @description
 * Provides an abstract extensible shared data service. Used to store any data to be used either the SmartEdit
 * application or the SmartEdit container.
 *
 * This class serves as an interface and should be extended, not instantiated.
 */
export class ISharedDataService {
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:ISharedDataService#get
     * @methodOf smarteditServicesModule.interface:ISharedDataService
     *
     * @description
     * Get the data for the given key.
     *
     * @param {String} key The key of the data to fetch
     */
    get(key: string): angular.IPromise<Cloneable>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:ISharedDataService#set
     * @methodOf smarteditServicesModule.interface:ISharedDataService
     *
     * @description
     * Set data for the given key.
     *
     * @param {String} key The key of the data to set
     * @param {object} value The value of the data to set
     */
    set(key: string, value: Cloneable): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:ISharedDataService#update
     * @methodOf smarteditServicesModule.interface:ISharedDataService
     *
     * @description
     * Convenience method to retrieve and modify on the fly the content stored under a given key
     *
     * @param {String} key The key of the data to store
     * @param {Function} modifyingCallback callback fed with the value stored under the given key. The callback must return the new value of the object to update.
     */
    update(key: string, modifyingCallback: (oldValue: any) => any): angular.IPromise<void>;
}

/// <reference types="angular" />
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IAuthToken
 * @description
 * Interface for Auth token
 */
export interface IAuthToken {
    access_token: string;
    expires_in: number;
    refresh_token: string;
    scope: string;
    token_type: string;
}
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IStorageService
 * @description
 * Interface for StorageService
 */
export class IStorageService {
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#isInitialized
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method is used to determine if the storage service has been initialized properly. It
     * makes sure that the smartedit-sessions cookie is available in the browser.
     *
     * @returns {Boolean} Indicates if the storage service was properly initialized.
     */
    isInitialized(): angular.IPromise<boolean>;
    /**
     * @deprecated since 6.6
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#storePrincipalIdentifier
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method is used to store the principal's login name in storage service. Deprecated since 6.6.
     *
     * @param {String} principalUID Value associated to store principal's login.
     */
    storePrincipalIdentifier(principalUID: string): angular.IPromise<void>;
    /**
     * @deprecated since 6.6
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#removePrincipalIdentifier
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method is used to remove the principal's UID from storage service. Deprecated since 6.6.
     *
     */
    removePrincipalIdentifier(): angular.IPromise<void>;
    /**
     * @deprecated since 6.6
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#getPrincipalIdentifier
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method is used to retrieve the principal's login name from storage service. Deprecated since 6.6.
     *
     * @returns {String} principalNameValue principal's name associated with the key.
     */
    getPrincipalIdentifier(): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#storeAuthToken
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method creates and stores a new key/value entry. It associates an authentication token with a
     * URI.
     *
     * @param {String} authURI The URI that identifies the resource(s) to be authenticated with the authToken. Will be used as a key.
     * @param {String} auth The token to be used to authenticate the user in the provided URI.
     */
    storeAuthToken(authURI: string, auth: IAuthToken): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#getAuthToken
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method is used to retrieve the authToken associated with the provided URI.
     *
     * @param {String} authURI The URI for which the associated authToken is to be retrieved.
     * @returns {String} The authToken used to authenticate the current user in the provided URI.
     */
    getAuthToken(authURI: string): angular.IPromise<IAuthToken>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#removeAuthToken
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * Removes the authToken associated with the provided URI.
     *
     * @param {String} authURI The URI for which its authToken is to be removed.
     */
    removeAuthToken(authURI: string): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#removeAllAuthTokens
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method removes all authURI/authToken key/pairs from the storage service.
     */
    removeAllAuthTokens(): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#getValueFromCookie
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * Retrieves the value stored in the cookie identified by the provided name.
     */
    getValueFromCookie(cookieName: string, isEncoded: boolean): angular.IPromise<any>;
    putValueInCookie(cookieName: string, value: any, encode: boolean): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#setItem
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method is used to store the item.
     *
     * @param {String} key The key of the item.
     * @param {any} value The value of the item.
     */
    setItem(key: string, value: any): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#getItem
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * Retrieves the value for a given key.
     *
     * @param {String} key The key of the item.
     *
     * @returns {Promise<any>} A promise that resolves to the item value.
     */
    getItem(key: string): angular.IPromise<any>;
}


/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IToolbarItem
 *
 * @description
 * Interface for ToolbarItem
 */
export interface IToolbarItem extends IFeature, IPrioritized {
    /**
     * @ngdoc property
     * @name iconClassName
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description List of classes used to display icons from fonts
     */
    iconClassName?: string;
    /**
     * @ngdoc property
     * @name icons
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description A list of image URLs for the icon images to be displayed in the toolbar for the items. The images are only available for ACTION and HYBRID_ACTION toolbar items.
     */
    icons?: string[];
    /**
     * @ngdoc property
     * @name include
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description The URL to the HTML template. By default, templates are available for TEMPLATE and HYBRID_ACTION toolbar items.
     */
    include?: string;
    /**
     * @ngdoc property
     * @name contextTemplate
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description The template of the context to be displayed. An optional parameter.
     */
    contextTemplate?: string;
    /**
     * @ngdoc property
     * @name contextTemplateUrl
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description The templateUrl that prints the context associated to the toolbar item. An optional parameter.
     */
    contextTemplateUrl?: string;
    /**
     * @ngdoc property
     * @name keepAliveOnClose
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description keepAliveOnClose keeps the dropdown content in the DOM on close. This is an optional parameter.
     */
    keepAliveOnClose?: boolean;
    /**
     * @ngdoc property
     * @name section
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description Determines the sections(left, middle or right) of the item in the toolbar.
     */
    section?: string;
    /**
     * @ngdoc property
     * @name toolbarId
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description The key that uniquely identifies the toolbar that the feature is added to.
     */
    toolbarId: string;
    /**
     * @ngdoc property
     * @name type
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description The type of toolbar item. The possible value are: TEMPLATE, ACTION, and HYBRID_ACTION.
     */
    type: string;
    /**
     * @ngdoc property
     * @name callback
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description The callback that is triggered when the toolbar action item is clicked.
     */
    callback?: () => void;
}


export interface IURIBuilder {
    build(): string;
    replaceParams(params: TypedMap<string>): IURIBuilder;
}

export interface IUriContext {
    [index: string]: string;
}

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IUrlService
 *
 * @description
 * Provides an abstract extensible url service, Used to open a given URL
 * in a new browser url upon invocation.
 *
 * This class serves as an interface and should be extended, not instantiated.
 */

export class IUrlService {
    
    
    
    
    
    
    constructor(PAGE_CONTEXT_SITE_ID: string, PAGE_CONTEXT_CATALOG: string, PAGE_CONTEXT_CATALOG_VERSION: string, CONTEXT_SITE_ID: string, CONTEXT_CATALOG: string, CONTEXT_CATALOG_VERSION: string);
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IUrlService#openUrlInPopup
     * @methodOf smarteditServicesModule.interface:IUrlService
     *
     * @description
     * Opens a given URL in a new browser pop up without authentication.
     *
     * @param {String} url - the URL we wish to open.
     */
    openUrlInPopup(url: string): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IUrlService#path
     * @methodOf smarteditServicesModule.interface:IUrlService
     *
     * @description
     * Navigates to the given path in the same browser tab.
     *
     * @param {String} path - the path we wish to navigate to.
     */
    path(path: string): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IUrlService#buildUriContext
     * @methodOf smarteditServicesModule.interface:IUrlService
     *
     * @description
     * Returns a uri context array populated with the given siteId, catalogId and catalogVersion information
     *
     * @param {String} siteId - site Id
     * @param {String} catalogId - catalog Id
     * @param {String} catalogVersion - catalog version
     *
     * @return {IUriContext} uri context array
     */
    buildUriContext(siteId: string, catalogId: string, catalogVersion: string): IUriContext;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IUrlService#buildPageUriContext
     * @methodOf smarteditServicesModule.interface:IUrlService
     *
     * @description
     * Returns a page uri context array populated with the given siteId, catalogId and catalogVersion information
     *
     * @param {String} siteId - site Id
     * @param {String} catalogId - catalog Id
     * @param {String} catalogVersion - catalog version
     *
     * @return {IUriContext} uri context array
     */
    buildPageUriContext(siteId: string, catalogId: string, catalogVersion: string): IUriContext;
}

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IWaitDialogService
 *
 * @description
 * This service be used in order to display (or hide) a 'loading' overlay. The overlay should display on top of everything, preventing
 * the user from doing any action until the overlay gets hidden.
 */
export class IWaitDialogService {
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IWaitDialogService#showWaitModal
     * @methodOf smarteditServicesModule.interface:IWaitDialogService
     *
     * @description
     * This method can be called to display the loading overlay.
     *
     * @param {String} [customLoadingMessageLocalizedKey="se.wait.dialog.message"] The i18n key that corresponds to the message to be displayed.
     */
    showWaitModal(customLoadingMessageLocalizedKey?: string): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IWaitDialogService#hideWaitModal
     * @methodOf smarteditServicesModule.interface:IWaitDialogService
     *
     * @description
     * Removes the loading overlay.
     */
    hideWaitModal(): void;
}

/// <reference types="angular" />

/**
 * @ngdoc interface
 * @name smarteditCommonsModule.interface:ILanguage
 * @description
 * Interface for language information
 */
export interface ILanguage extends Payload {
    active: boolean;
    isocode: string;
    name: string;
    nativeName: string;
    required: boolean;
}
export interface IToolingLanguage {
    isoCode: string;
    name: string;
}
/**
 * @ngdoc service
 * @name smarteditCommonsModule.service:LanguageService
 */
export class LanguageService {
    
    
    
    
    
    
    
    
    
    
    
    
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:LanguageService#getBrowserLanguageIsoCode
     * @methodOf smarteditCommonsModule.service:LanguageService
     *
     * @deprecated since 1808
     *
     * @description
     * Uses the browser's current locale to determine the selected language ISO code.
     *
     * @returns {String} The language ISO code of the browser's currently selected locale.
     */
    getBrowserLanguageIsoCode(): string;
    setInitialized(initialized: boolean): void;
    isInitialized(): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:LanguageService#getBrowserLocale
     * @methodOf smarteditCommonsModule.service:LanguageService
     *
     * @deprecated since 1808 - use browserService instead.
     *
     * @description
     * determines the browser locale in the format en_US
     *
     * @returns {string} the browser locale
     */
    getBrowserLocale(): string;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:LanguageService#getResolveLocale
     * @methodOf smarteditCommonsModule.service:LanguageService
     *
     * @description
     * Resolve the user preference tooling locale. It determines in the
     * following order:
     *
     * 1. Check if the user has previously selected the language
     * 2. Check if the user browser locale is supported in the system
     *
     * @returns {angular.IPromise<string>} the locale
     */
    getResolveLocale(): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:LanguageService#getResolveLocaleIsoCode
     * @methodOf smarteditCommonsModule.service:LanguageService
     *
     * @description
     * Resolve the user preference tooling locale ISO code. i.e.: If the selected tooling language is 'en_US',
     * the resolved value will be 'en'.
     *
     * @returns {angular.IPromise<string>} A promise that resolves to the isocode of the tooling language.
     */
    getResolveLocaleIsoCode(): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:LanguageService#getLanguagesForSite
     * @methodOf smarteditCommonsModule.service:LanguageService
     *
     * @description
     * Fetches a list of language descriptors for the specified storefront site UID.
     * The object containing the list of sites is fetched using REST calls to the cmswebservices languages API.
     *
     * @param {string} siteUID the site unique identifier.
     *
     * @returns {angular.IPromise<ILanguage[]>} A promise that resolves to an array of ILanguage.
     */
    getLanguagesForSite(siteUID: string): angular.IPromise<ILanguage[]>;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:LanguageService#getToolingLanguages
     * @methodOf smarteditCommonsModule.service:LanguageService
     *
     * @description
     * Retrieves a list of language descriptors using REST calls to the smarteditwebservices i18n API.
     *
     * @returns {angular.IPromise<IToolingLanguage[]>} A promise that resolves to an array of IToolingLanguage.
     */
    getToolingLanguages(): angular.IPromise<IToolingLanguage[]>;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:LanguageService#setSelectedToolingLanguage
     * @methodOf smarteditCommonsModule.service:LanguageService
     *
     * @description
     * Set the user preference language in the storage service
     *
     * @param {IToolingLanguage} language the language object to be saved.
     */
    setSelectedToolingLanguage(language: IToolingLanguage): void;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:LanguageService#registerSwitchLanguage
     * @methodOf smarteditCommonsModule.service:LanguageService
     *
     * @description
     * Register a callback function to the gateway in order to switch the tooling language
     */
    registerSwitchLanguage(): void;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:LanguageService#convertBCP47TagToJavaTag
     * @methodOf smarteditCommonsModule.service:LanguageService
     *
     * @description
     * Method converts the BCP47 language tag representing the locale to the default java representation.
     * For example, method converts "en-US" to "en_US".
     *
     * @param {string} languageTag the language tag to be converted.
     *
     * @returns {string} the languageTag in java representation
     */
    convertBCP47TagToJavaTag(languageTag: string): string;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:LanguageService#convertJavaTagToBCP47Tag
     * @methodOf smarteditCommonsModule.service:LanguageService
     *
     * @description
     * Method converts the default java language tag representing the locale to the BCP47 representation.
     * For example, method converts "en_US" to "en-US".
     *
     * @param {string} languageTag the language tag to be converted.
     *
     * @returns {string} the languageTag in BCP47 representation
     */
    convertJavaTagToBCP47Tag(languageTag: string): string;
    
}



/// <reference types="angular" />

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IPerspectiveService
 *
 * @description
 * Interface for Perspective Service
 */
export class IPerspectiveService {
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPerspectiveService#register
     * @methodOf smarteditServicesModule.interface:IPerspectiveService
     *
     * @description
     * This method registers a perspective.
     * When an end user selects a perspective in the SmartEdit web application,
     * all features bound to the perspective will be enabled when their respective enablingCallback functions are invoked
     * and all features not bound to the perspective will be disabled when their respective disablingCallback functions are invoked.
     *
     * @param {Object} configuration The perspective's configuration {@link smarteditServicesModule.interface:IPerspective IPerspective}
     *
     * @return {angular.IPromise<void>} An empty promise
     */
    register(configuration: IPerspective): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPerspectiveService#switchTo
     * @methodOf smarteditServicesModule.interface:IPerspectiveService
     *
     * @description
     * This method activates a perspective identified by its key and deactivates the currently active perspective.
     * Activating a perspective consists in activating any feature that is bound to the perspective
     * or any feature that is bound to the perspective's referenced perspectives and deactivating any features
     * that are not bound to the perspective or to its referenced perspectives.
     * After the perspective is changed, the {@link seConstantsModule.object:EVENT_PERSPECTIVE_CHANGED
     * EVENT_PERSPECTIVE_CHANGED} event is published on the {@link smarteditCommonsModule.service:CrossFrameEventService
     * crossFrameEventService}, with no data.
     *
     * @param {String} key The key that uniquely identifies the perspective to be activated. This is the same key as the key used in the {@link smarteditServicesModule.interface:IPerspectiveService#methods_register register} method.
     * @return {angular.IPromise<void>} An empty promise
     */
    switchTo(key: string): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPerspectiveService#hasActivePerspective
     * @methodOf smarteditServicesModule.interface:IPerspectiveService
     *
     * @description
     * This method returns true if a perspective is selected.
     *
     * @returns {angular.IPromise<boolean>} A promise with the value of the key of the active perspective.
     */
    hasActivePerspective(): angular.IPromise<boolean>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPerspectiveService#selectDefault
     * @methodOf smarteditServicesModule.interface:IPerspectiveService
     *
     * @description
     * This method switches the currently-selected perspective to the default perspective.
     * It will also disable all features for the default perspective before enabling them all back.
     * If no value has been stored in the smartedit-perspectives cookie, the value of the default perspective is se.none.
     * If a value is stored in the cookie, that value is used as the default perspective.
     *
     * @return {angular.IPromise<void>} An empty promise
     */
    selectDefault(): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPerspectiveService#isEmptyPerspectiveActive
     * @methodOf smarteditServicesModule.interface:IPerspectiveService
     *
     * @description
     * This method returns true if the current active perspective is the Preview mode (No active overlay).
     *
     * @returns {angular.IPromise<boolean>} A promise with the boolean flag that indicates if the current perspective is the Preview mode.
     */
    isEmptyPerspectiveActive(): angular.IPromise<boolean>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPerspectiveService#refreshPerspective
     * @methodOf smarteditServicesModule.interface:IPerspectiveService
     *
     * @description
     * This method is used to refresh the prespective.
     * If there is an exising perspective set then it is refreshed by replaying all the features associated to the current perspective.
     * If there is no perspective set or if the perspective is not permitted then we set the default perspective.
     *
     * @return {angular.IPromise<void>} An empty promise
     */
    refreshPerspective(): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPerspectiveService#getActivePerspectiveKey
     * @methodOf smarteditServicesModule.interface:IPerspectiveService
     *
     * @description
     * 	This method returns the key of the perspective that is currently loaded.
     *
     * @returns {angular.IPromise<string>} A promise that resolves to the key of the current perspective loaded in the storefront, null otherwise.
     */
    getActivePerspectiveKey(): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPerspectiveService#isHotkeyEnabledForActivePerspective
     * @methodOf smarteditServicesModule.interface:IPerspectiveService
     *
     * @description
     * This method returns true if the active perspective has the hotkey enabled
     *
     * @returns {angular.IPromise<boolean>} A promise with the boolean flag that indicates if the current perspective has the hotkey enabled.
     */
    isHotkeyEnabledForActivePerspective(): angular.IPromise<boolean>;
}




/**
 * @ngdoc service
 * @name smarteditServicesModule.service:PriorityService
 * @description
 * The PriorityService handles arrays of {@link smarteditServicesModule.interface:IPrioritized IPrioritized} elements
 */
export class PriorityService {
    
    constructor(encode: any);
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:PriorityService#sort<T>
     * @methodOf smarteditServicesModule.service:PriorityService
     *
     * @description
     * Will sort the candidate array by ascendign or descending priority.
     * Even if the priority is not defined for a number of elements, the sorting will still be consistent over invocations
     * @param {T[]} candidate the array of @link smarteditServicesModule.interface:IPrioritized IPrioritized} elements to be sorted
     * @param {boolean=} [ascending=true] if true, candidate will be sorted by ascending priority.
     * @returns {T[]} A promise resolving to the username,
     * previously mentioned as "principalUID", associated to the
     * authenticated user.
     */
    sort<T extends IPrioritized>(candidate: T[], ascending?: boolean): T[];
}

/// <reference types="angular" />



/**
 * @ngdoc service
 * @name smarteditServicesModule.service:AbstractCachedRestService
 *
 * @description
 * Base class to implement Cache enabled {@link smarteditServicesModule.interface:IRestService IRestServices}.
 * <br/>Implementing classes just need declare a class level {@link smarteditServicesModule.object:@CacheConfig @CacheConfig} annotation
 * with at least one {@link smarteditServicesModule.object:CacheAction CacheAction} and one {@link smarteditServicesModule.object:EvictionTag EvictionTag}.
 * <br/>Cache policies called by the set of {@link smarteditServicesModule.object:CacheAction CacheActions} will have access to
 * REST call response headers being added to the response under "headers" property.
 * <br/>Those headers are then stripped from the response.
 *
 * <h2>Usage</h2>
 * <pre>
 * &#64;CacheConfig({actions: [rarelyChangingContent], tags: [userEvictionTag]})
 * &#64;SeInjectable()
 * export class ProductCatalogRestService extends AbstractCachedRestService<IBaseCatalogs> {
 * 	constructor(restServiceFactory: IRestServiceFactory) {
 * 		super(restServiceFactory, '/productcatalogs');
 * 	}
 * }
 * </pre>
 */
export class AbstractCachedRestService<T> implements IRestService<T> {
    
    constructor(restServiceFactory: IRestServiceFactory, uri: string, identifier?: string);
    getById(identifier: string): angular.IPromise<T>;
    get(searchParams: void | Payload): angular.IPromise<T>;
    query(searchParams: Payload): angular.IPromise<T[]>;
    page(searchParams: Pageable): angular.IPromise<Page<T>>;
    update(payload: Payload): angular.IPromise<T>;
    remove(payload: Payload): angular.IPromise<void>;
    save(payload: Payload): angular.IPromise<T>;
}

export class CommonsRestServiceModule {
}




export class ContentCatalogRestService extends AbstractCachedRestService<IBaseCatalogs> {
    constructor(restServiceFactory: IRestServiceFactory);
}




export class ProductCatalogRestService extends AbstractCachedRestService<IBaseCatalogs> {
    constructor(restServiceFactory: IRestServiceFactory);
}




/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IRestService
 *
 * @description
 * Common interface of smartedit REST services generated by calls to {@link smarteditServicesModule.interface:restServiceFactory restServiceFactory#get<T>}
 * IRestService<T> has strongly typed methods in both signature and return type
 * When used in the smartedit application (as opposed to smarteditContainer) calls are proxied to the smarteditContainer
 * in order to prevent cross-origin issues in the case where smartEdit and the embedded storefront are in different domains.
 */
export interface IRestService<T> extends IReflectable<T> {
    activateMetadata?(): void;
    /**
     * @ngdoc service
     * @name smarteditServicesModule.interface:IRestService#getById
     * @methodOf smarteditServicesModule.interface:IRestService
     *
     * @description
     * Loads a component based on its identifier.
     *
     * @param {String} identifier The value of the object identifier.
     *
     * @returns {Object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of T
     */
    getById(identifier: string): angular.IPromise<T>;
    /**
     * @ngdoc service
     * @name smarteditServicesModule.interface:IRestService#get
     * @methodOf smarteditServicesModule.interface:IRestService
     *
     * @description
     * Loads a unique component based on its identifier that must match the specified get parameters.
     * <br/>The REST Service Factory evaluates placeholders in the URI, if any are provided, to verify if they
     * match the search parameters.
     *
     * @param {object} searchParams The object that contains the query parameters, which are then mapped to the
     * query string
     *
     * @returns {object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of T
     */
    get(searchParams: void | Payload): angular.IPromise<T>;
    /**
     * @ngdoc service
     * @name smarteditServicesModule.interface:IRestService#query
     * @methodOf smarteditServicesModule.interface:IRestService
     *
     * @description
     * Loads a list of components that match the specified search parameters.
     * <br/>The REST service evaluates the placeholders in the URI, if any are provided, to verify if
     * they match the search parameters.
     *
     * @param {object} searchParams The object that contains the query parameters, which are then mapped to the
     * query string
     *
     * @returns {object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of T[]
     */
    query(searchParams: Payload): angular.IPromise<T[]>;
    /**
     * @ngdoc service
     * @name smarteditServicesModule.interface:IRestService#page
     * @methodOf smarteditServicesModule.interface:IRestService
     * @description
     * To be called instead of {@link smarteditServicesModule.interface:IRestService#query query} when the list is wrapped by server in an object (ex: Page).
     * <br/>The service will evaluate any placeholder in the URI with matching search params.
     * @param {object} searchParams The object that contains the query parameters, which are then mapped to the
     * query string
     * @returns {object} a {@link https://docs.angularjs.org/api/ng/service/$q promise} of <Page<T>>
     */
    page(searchParams: Pageable): angular.IPromise<Page<T>>;
    /**
     * @ngdoc service
     * @name smarteditServicesModule.interface:IRestService#update
     * @methodOf smarteditServicesModule.interface:IRestService
     *
     * @description
     * Updates a component.  It appends the value of the identifier to the URI.
     *
     * @param {object} payload The object to be updated. <br/>The promise will be rejected if the payload does not contain the identifier.
     *
     * @returns {object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of T
     */
    update(payload: Payload): angular.IPromise<T>;
    /**
     * @ngdoc service
     * @name smarteditServicesModule.interface:IRestService#save
     * @methodOf smarteditServicesModule.interface:IRestService
     *
     * @description
     * Saves a component. It appends the value of the identifier to the URI.
     *
     * @param {object} payload The object to be saved.
     * <br/>The promise will be rejected if the payload does not contain the identifier.
     *
     * @returns {object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of T
     * to what the server returns.
     */
    save(payload: Payload): angular.IPromise<T>;
    /**
     * @ngdoc service
     * @name smarteditServicesModule.interface:IRestService#remove
     * @methodOf smarteditServicesModule.interface:IRestService
     *
     * @description
     * Deletes a component. It appends the value of the identifier to the URI.
     *
     * @param {object} payload The object to be updated.
     * <br/>The promise will be rejected if the payload does not contain the identifier.
     *
     * @returns {object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of void
     */
    remove(payload: Payload): angular.IPromise<void>;
}


/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:restServiceFactory
 *
 * @description
 * A factory used to generate a REST service wrapper for a given resource URL, providing a means to perform HTTP
 * operations (GET, POST, etc) for the given resource.
 */
export interface IRestServiceFactory {
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:restServiceFactory#get<T>
     * @methodOf smarteditServicesModule.interface:restServiceFactory
     *
     * @description
     * A factory method used to create a REST service of type {@link smarteditServicesModule.interface:IRestService IRestService<T>}
     * that points to the given resource URI.
     * The returned service wraps a $resource object. As opposed to a $resource, the REST services retrieved from the
     * restServiceFactory can only take one object argument. The object argument will automatically be split
     * into a parameter object and a payload object before they are delegated to the wrapped $resource object.
     * If the domain is set, the domain is prepended to the given URI.
     *
     * @param {String} uri The URI of the REST service to be retrieved.
     * @param {String=} identifier An optional parameter. The name of the placeholder that is appended to the end
     * of the URI if the name is not already provided as part of the URI. The default value is "identifier".
     * <pre>
     * 	if identifier is "resourceId" and uri is "resource/:resourceId/someValue", the target URI will remain the same.
     * 	if identifier is "resourceId" and uri is "resource", the target URI will be "resource/:resourceId".
     * </pre>
     *
     * @returns {IResourceService} A {@link smarteditServicesModule.interface:IResourceService IRestService} around a {@link https://docs.angularjs.org/api/ngResource/service/$resource $resource}
     */
    get<T>(uri: string, identifier?: string): IRestService<T>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:restServiceFactory#setDomain
     * @methodOf smarteditServicesModule.interface:restServiceFactory
     *
     * @description
     * When working with multiple services that reference the same domain, it is best to only specify relative
     * paths for the services and specify the context-wide domain in a separate location. The {@link
     * smarteditServicesModule.interface:restServiceFactory#get get} method of the {@link
     * smarteditServicesModule.interface:restServiceFactory restServiceFactory} will then prefix the specified service
     * URIs with the domain and a forward slash.
     *
     * @param {String} domain The context-wide domain that all URIs will be prefixed with when services are
     * created/when a service is created
     *
     * @deprecated since 6.7
     */
    setDomain?(domain: string): void;
}

/// <reference types="angular" />


export class PermissionsRestService {
    
    
    constructor(restServiceFactory: IRestServiceFactory);
    get(queryData: IPermissionsRestServiceQueryData): angular.IPromise<IPermissionsRestServiceResult>;
}

export * from './AbstractCachedRestService';
export * from './IRestService';
export * from './IRestServiceFactory';
export * from './daos/ContentCatalogRestService';
export * from './daos/ProductCatalogRestService';
export * from './PermissionsRestService';


export class SmarteditBootstrapGateway {
    constructor(gatewayFactory: GatewayFactory);
}

/**
 * @ngdoc overview
 * @name smarteditCommonsModule
 *
 * @description
 * Module containing all the services shared within the smartedit commons.
 */
export class SmarteditCommonsModule {
}

/**
 * @name smarteditRootModule
 *
 * @description
 * Module acts as a root module of smartedit commons module.
 */
export class SmarteditRootModule {
}

export * from './manager/NamespacedStorageManager';
export * from './manager/StorageManagerFactory';
export * from './manager/StorageNamespaceConverter';
export * from './IStorage';
export * from './IStorageController';
export * from './IStorageFactory';
export * from './IStorageGateway';
export * from './IStorageManager';
export * from './IStorageManagerFactory';
export * from './IStorageManagerGateway';
export * from './IStorageOptions';
export * from './IStorageProperties';
export * from './IStoragePropertiesService';








export type EventHandler = (eventId: string, eventData?: any) => angular.IPromise<any> | any;
/**
 * @ngdoc service
 * @name smarteditCommonsModule.service:SystemEventService
 * @description
 *
 * The SystemEventService is used to transmit events synchronously or asynchronously. It is supported by the SmartEdit {@link smarteditCommonsModule.service:GatewayFactory gatewayFactory} to propagate events between SmartEditContainer and SmartEdit.
 * It also contains options to publish events, as well as subscribe the event handlers.
 *
 */
export class SystemEventService {
    
    
    
    
    
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:SystemEventService#publish
     * @methodOf smarteditCommonsModule.service:SystemEventService
     *
     * @description
     * send the event with data synchronously.
     *
     * @param {String} eventId The identifier of the event.
     * @param {any=} data The event payload. It is optional parameter.
     *
     * @return {angular.IPromise<any>} A promise with resolved data of last subscriber or with the rejected error reason
     */
    publish(eventId: string, data?: any): angular.IPromise<any>;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:SystemEventService#sendSynchEvent
     * @methodOf smarteditCommonsModule.service:SystemEventService
     * @deprecated since 1808
     * @description
     * send the event with data synchronously.
     *
     * @param {String} eventId The identifier of the event.
     * @param {any=} data The event payload. It is optional parameter.
     *
     * @return {angular.IPromise<any>} A promise with resolved data of last subscriber or with the rejected error reason
     */
    sendSynchEvent(eventId: string, data?: any): angular.IPromise<any>;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:SystemEventService#publishAsync
     * @methodOf smarteditCommonsModule.service:SystemEventService
     *
     * @description
     * send the event with data asynchronously.
     *
     * @param {String} eventId The identifier of the event.
     * @param {any=} data The event payload. It is an optional parameter.
     *
     * @return {angular.IPromise<any>} A deferred promise
     */
    publishAsync(eventId: string, data?: any): angular.IPromise<any>;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:SystemEventService#sendAsynchEvent
     * @methodOf smarteditCommonsModule.service:SystemEventService
     * @deprecated since 1808
     * @description
     * send the event with data asynchronously.
     *
     * @param {String} eventId The identifier of the event.
     * @param {any=} data The event payload. It is an optional parameter.
     *
     * @return {angular.IPromise<any>} A deferred promise
     */
    sendAsynchEvent(eventId: string, data?: any): angular.IPromise<any>;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:SystemEventService#subscribe
     * @methodOf smarteditCommonsModule.service:SystemEventService
     *
     * @description
     * method to subscribe the event handler given the eventId and handler
     *
     * @param {String} eventId The identifier of the event.
     * @param {EventHandler} handler The event handler, a callback function which can either return a promise or directly a value.
     *
     * @return {() => void} unsubscribeFn Function to unsubscribe the event handler
     */
    subscribe(eventId: string, handler: EventHandler): () => void;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.service:SystemEventService#registerEventHandler
     * @methodOf smarteditCommonsModule.service:SystemEventService
     * @deprecated since 1808
     * @description
     * method to subscribe the event handler given the eventId and handler
     *
     * @param {String} eventId The identifier of the event.
     * @param {EventHandler} handler The event handler, a callback function which can either return a promise or directly a value.
     *
     * @return {() => void} unsubscribeFn Function to unsubscribe the event handler
     */
    registerEventHandler(eventId: string, handler: EventHandler): () => void;
    
    
}






export interface IWizardActionStrategy {
    applyStrategy(wizardService: WizardService, conf: WizardConfig): void;
}




/**
 * @ngdoc service
 * @name wizardServiceModule.modalWizard
 *
 * @description
 * The modalWizard service is used to create wizards that are embedded into the {@link modalServiceModule modalService}
 */
export class ModalWizard {
    
    constructor(modalService: IModalService);
    /**
     * @ngdoc method
     * @name wizardServiceModule.modalWizard#open
     * @methodOf wizardServiceModule.modalWizard
     *
     * @description
     * Open provides a simple way to create modal wizards, with much of the boilerplate taken care of for you, such as look
     * and feel, and wizard navigation.
     *
     * @param {WizardAction} conf configuration
     * @param {String|function|Array} conf.controller An angular controller which will be the underlying controller
     * for all of the wizard. This controller MUST implement the function <strong>getWizardConfig()</strong> which
     * returns a {@link wizardServiceModule.object:ModalWizardConfig ModalWizardConfig}.<br />
     * If you need to do any manual wizard manipulation, 'wizardManager' can be injected into your controller.
     * See {@link wizardServiceModule.WizardManager WizardManager}
     * @param {String} conf.controllerAs (OPTIONAL) An alternate controller name that can be used in your wizard step
     * @param {=String=} conf.properties A map of properties to initialize the wizardManager with. They are accessible under wizardManager.properties.
     * templates. By default the controller name is wizardController.
     *
     * @returns {function} {@link https://docs.angularjs.org/api/ng/service/$q promise} that will either be resolved (wizard finished) or
     * rejected (wizard cancelled).
     */
    open(config: WizardAction): angular.IPromise<any>;
    
}



/// <reference types="angular-mocks" />



export interface WizardAction {
    id?: string;
    i18n: string;
    controller?: angular.IControllerService;
    controllerAs?: string;
    isMainAction?: boolean;
    destinationIndex?: number;
    stepIndex?: number;
    wizardService?: WizardService;
    properties?: TypedMap<any>;
    isCurrentStep?(): boolean;
    enableIfCondition?(): boolean;
    executeIfCondition?(): boolean;
    execute?(wizardService: WizardService): void;
}





/**
 * @ngdoc object
 * @name wizardServiceModule.object:WizardStepConfig
 * @description
 * A plain JSON object, representing the configuration options for a single step in a wizard
 */
export interface WizardStep {
    /**
     * @ngdoc property
     * @name id
     * @propertyOf wizardServiceModule.object:WizardStepConfig
     * @description
     * An optional unique ID for this step in the wizard. If no ID is provided, one is automatically generated.<br />
     * You may choose to provide an ID, making it easier to reference this step explicitly via the wizard service, or
     * be able to identify for which step a callback is being triggered.
     */
    id: string;
    /**
     * @ngdoc property
     * @name templateUrl
     * @propertyOf wizardServiceModule.object:WizardStepConfig
     * @description The url of the html template for this step
     */
    templateUrl: string;
    /**
     * @ngdoc property
     * @name title
     * @propertyOf wizardServiceModule.object:WizardStepConfig
     * @description An i18n key, representing the title that will be displayed at the top of the wizard for this step.
     */
    /**
     * @ngdoc property
     * @name name
     * @propertyOf wizardServiceModule.object:WizardStepConfig
     * @description An i18n key representing a meaning (short) name for this step.
     * This name will be displayed in the wizard navigation menu.
     */
    name: string;
    title: string;
    actions: WizardAction[];
}
/**
 * @ngdoc object
 * @name wizardServiceModule.object:ModalWizardConfig
 * @description
 * A plain JSON object, representing the configuration options for a modal wizard
 */
export interface WizardConfig {
    /**
     * @ngdoc property
     * @name steps (Array)
     * @propertyOf wizardServiceModule.object:ModalWizardConfig
     * @description An ordered array of {@link wizardServiceModule.object:WizardStepConfig WizardStepConfig}
     */
    steps: WizardStep[];
    actionStrategy: IWizardActionStrategy;
    /**
     * @ngdoc property
     * @name resultFn (Function)
     * @propertyOf wizardServiceModule.object:ModalWizardConfig
     * @description An optional callback function that has no parameters. This callback is triggered after the done
     * action is fired, and the wizard is about to be closed. If this function is defined and returns a value, this
     * value will be returned in the resolved promise returned by the {@link wizardServiceModule.modalWizard#methods_open modalWizard.open()}
     * This is an easy way to pass a result from the wizard to the caller.
     */
    resultFn: () => void;
    /**
     * @ngdoc property
     * @name isFormValid (Function)
     * @propertyOf wizardServiceModule.object:ModalWizardConfig
     * @description An optional callback function that receives a single parameter, the current step ID. This callback
     * is used to enable/disable the next action and the done action.
     * The callback should return a boolean to enabled the action. Null, or if this callback is not defined defaults to
     * true (enabled)
     */
    isFormValid?: (stepId: string) => boolean;
    /**
     * @ngdoc property
     * @name onNext (Function)
     * @propertyOf wizardServiceModule.object:ModalWizardConfig
     * @description An optional callback function that receives a single parameter, the current step ID.
     * This callback is triggered after the next action is fired. You have the opportunity to halt the Next action by
     * returning promise and rejecting it, otherwise the wizard will continue and load the next step.
     */
    onNext?: (stepId: string) => boolean;
    /**
     * @ngdoc property
     * @name onCancel (Function)
     * @propertyOf wizardServiceModule.object:ModalWizardConfig
     * @description An optional callback function that receives a single parameter, the current step ID.
     * This callback is triggered after the cancel action is fired. You have the opportunity to halt the cancel action
     * (thereby stopping the wizard from being closed), by returning a promise and rejecting it, otherwise the wizard will
     * continue the cancel action.
     */
    onCancel?: (stepId: string) => boolean;
    /**
     * @ngdoc property
     * @name onDone (Function)
     * @propertyOf wizardServiceModule.object:ModalWizardConfig
     * @description An optional callback function that has no parameters. This callback is triggered after the done
     * action is fired. You have the opportunity to halt the done action (thereby stopping the wizard from being closed),
     * by returning a promise and rejecting it, otherwise the wizard will continue and close the wizard.
     */
    onDone?: (stepId: string) => boolean;
    /**
     * @ngdoc property
     * @name doneLabel (String)
     * @propertyOf wizardServiceModule.object:ModalWizardConfig
     * @description An optional i18n key to override the default label for the Done button
     */
    doneLabel?: string;
    /**
     * @ngdoc property
     * @name nextLabel (String)
     * @propertyOf wizardServiceModule.object:ModalWizardConfig
     * @description An optional i18n key to override the default label for the Next button
     */
    nextLabel?: string;
    /**
     * @ngdoc property
     * @name backLabel (String)
     * @propertyOf wizardServiceModule.object:ModalWizardConfig
     * @description An optional i18n key to override the default label for the Back button
     */
    backLabel?: string;
    /**
     * @ngdoc property
     * @name cancelLabel (String)
     * @propertyOf wizardServiceModule.object:ModalWizardConfig
     * @description An optional i18n key to override the default label for the Cancel button
     */
    cancelLabel?: string;
    templateOverride?: string;
    cancelAction?: WizardAction;
}
/**
 * @ngdoc service
 * @name wizardServiceModule.WizardManager
 *
 * @description
 * The Wizard Manager is a wizard management service that can be injected into your wizard controller.
 *
 */
export class WizardService {
    
    
    
    onLoadStep: (index: number, nextStep: WizardStep) => void;
    onClose: (result: unknown) => void;
    onCancel: () => void;
    onStepsUpdated: (steps: WizardStep[]) => void;
    properties: TypedMap<any>;
    
    
    
    
    
    constructor($q: angular.IQService, defaultWizardActionStrategy: IWizardActionStrategy, generateIdentifier: () => string);
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#goToStepWithIndex
     * @methodOf wizardServiceModule.WizardManager
     * @description Navigates the wizard to the given step
     * @param {Number} index The 0-based index from the steps array returned by the wizard controllers getWizardConfig() function
     */
    goToStepWithIndex(index: number): void;
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#goToStepWithId
     * @methodOf wizardServiceModule.WizardManager
     * @description Navigates the wizard to the given step
     * @param {String} id The ID of a step returned by the wizard controllers getWizardConfig() function. Note that if
     * no id was provided for a given step, then one is automatically generated.
     */
    goToStepWithId(id: string): void;
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#addStep
     * @methodOf wizardServiceModule.WizardManager
     * @description Adds an additional step to the wizard at runtime
     * @param {Object} newStep A {@link wizardServiceModule.object:WizardStepConfig WizardStepConfig}
     * @param {Number} index (OPTIONAL) A 0-based index position in the steps array. Default is 0.
     */
    addStep(newStep: WizardStep, index: number): void;
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#removeStepById
     * @methodOf wizardServiceModule.WizardManager
     * @description Remove a step form the wizard at runtime. If you are removing the currently displayed step, the
     * wizard will return to the first step. Removing all the steps will result in an error.
     * @param {String} id The id of the step you wish to remove
     */
    removeStepById(id: string): void;
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#removeStepByIndex
     * @methodOf wizardServiceModule.WizardManager
     * @description Remove a step form the wizard at runtime. If you are removing the currently displayed step, the
     * wizard will return to the first step. Removing all the steps will result in an error.
     * @param {Number} index The 0-based index of the step you wish to remove.
     */
    removeStepByIndex(index: number): void;
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#close
     * @methodOf wizardServiceModule.WizardManager
     * @description Close the wizard. This will return a resolved promise to the creator of the wizard, and if any
     * resultFn was provided in the {@link wizardServiceModule.object:ModalWizardConfig ModalWizardConfig} the returned
     * value of this function will be passed as the result.
     */
    close(): void;
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#cancel
     * @methodOf wizardServiceModule.WizardManager
     * @description Cancel the wizard. This will return a rejected promise to the creator of the wizard.
     */
    cancel(): void;
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#getSteps
     * @methodOf wizardServiceModule.WizardManager
     * @returns {Array} An array of all the steps in the wizard
     */
    getSteps(): WizardStep[];
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#getStepIndexFromId
     * @methodOf wizardServiceModule.WizardManager
     * @param {String} id A step ID
     * @returns {Number} The index of the step with the provided ID
     */
    getStepIndexFromId(id: string): number;
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#containsStep
     * @methodOf wizardServiceModule.WizardManager
     * @param {String} id A step ID
     * @returns {Boolean} True if the ID exists in one of the steps
     */
    containsStep(stepId: string): boolean;
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#getCurrentStepId
     * @methodOf wizardServiceModule.WizardManager
     * @returns {String} The ID of the currently displayed step
     */
    getCurrentStepId(): string;
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#getCurrentStepIndex
     * @methodOf wizardServiceModule.WizardManager
     * @returns {Number} The index of the currently displayed step
     */
    getCurrentStepIndex(): number;
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#getCurrentStep
     * @methodOf wizardServiceModule.WizardManager
     * @returns {Object} The currently displayed step
     */
    getCurrentStep(): WizardStep;
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#getStepsCount
     * @methodOf wizardServiceModule.WizardManager
     * @returns {Number} The number of steps in the wizard. This should always be equal to the size of the array
     * returned by {@link wizardServiceModule.WizardManager#methods_getSteps getSteps()}
     */
    getStepsCount(): number;
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#getStepWithId
     * @methodOf wizardServiceModule.WizardManager
     * @param {String} id The ID of a step
     * @returns {Object} The {@link wizardServiceModule.object:WizardStepConfig step} with the given ID
     */
    getStepWithId(id: string): WizardStep;
    /**
     * @ngdoc method
     * @name wizardServiceModule.WizardManager#getStepWithIndex
     * @methodOf wizardServiceModule.WizardManager
     * @param {Number} index The ID of a step
     * @returns {Object} The {@link wizardServiceModule.object:WizardStepConfig step} with the given index
     */
    getStepWithIndex(index: number): WizardStep;
    
    
}

/**
 * @ngdoc overview
 * @name wizardServiceModule
 *
 * @description
 * # The wizardServiceModule
 * The wizardServiceModule is a module containing all wizard related services
 * # Creating a modal wizard in a few simple steps
 * 1. Add the wizardServiceModule to your module dependencies
 * 2. Inject {@link wizardServiceModule.modalWizard modalWizard} where you want to use the wizard.
 * 3. Create a new controller for your wizard. This controller will be used for all steps of the wizard.
 * 4. Implement a function in your new controller called <strong>getWizardConfig</strong> that returns a {@link wizardServiceModule.object:ModalWizardConfig ModalWizardConfig}
 * 5. Use {@link wizardServiceModule.modalWizard#methods_open modalWizard.open()} passing in your new controller
 *
 * <pre>
 * @SeInjectable()
 * export class MyWizardService {
 * 		constructor(
 * 		open() {
 * 			this.modalWizard.open({
 * 				controller: (wizardManager: any) => {
 * 					'ngInject';
 * 					return {
 * 						steps: [{
 * 							id: 'step1',
 * 							name: 'i18n.step1.name',
 * 							title: 'i18n.step1.title',
 * 							templateUrl: 'some/template1.html'
 * 						}, {
 * 							id: 'step2',
 * 							name: 'i18n.step2.name',
 * 							title: 'i18n.step2.title',
 * 							templateUrl: 'some/template2.html'
 * 						}]
 * 					};
 * 				}
 * 			});
 * 		}
 * }
 * </pre>
 */
export class WizardServiceModule {
}

/**
 * @ngdoc service
 * @name functionsModule.service:CryptographicUtils
 *
 * @description
 * utility service around Cryptographic operations.
 */
export class CryptographicUtils {
    /**
     * @ngdoc method
     * @name functionsModule.service:CryptographicUtils#sha1Hash
     * @methodOf functionsModule.service:CryptographicUtils
     *
     * @description
     * A utility function that takes an input string and provides a cryptographic SHA1 hash value.
     *
     * @param {String} data The input string to be encrypted.
     * @returns {String} the encrypted hashed result.
     */
    sha1Hash(data: string): string;
}

/// <reference types="angular-mocks" />

export interface DiscardablePromise<T> {
    promise: angular.IPromise<T> | Promise<T>;
    successCallback: (...args: any[]) => any;
    failureCallback: (...args: any[]) => any;
    discardableHolder?: {
        successCallback: (...args: any[]) => any;
        failureCallback: (...args: any[]) => any;
    };
}
/**
 * @ngdoc service
 * @name functionsModule.service:DiscardablePromiseUtils
 * @description
 * helper to handle competing promises
 */
export class DiscardablePromiseUtils {
    
    
    constructor($log: angular.ILogService);
    /**
     * @ngdoc method
     * @methodOf DiscardablePromiseUtils
     * @name functionsModule.service:DiscardablePromiseUtils#apply
     * @methodOf functionsModule.service:DiscardablePromiseUtils
     * @description
     * selects a new promise as candidate for invoking a given callback
     * each invocation of this method for a given key discards the previously selected promise
     * @param {string} key the string key identifying the discardable promise
     * @param {Promise} promise the discardable promise instance once a new candidate is called with this method
     * @param {Function} successCallback the success callback to ultimately apply on the last promise not discarded
     * @param {Function=} failureCallback the failure callback to ultimately apply on the last promise not discarded. Optional.
     */
    apply<T>(key: string, promise: angular.IPromise<T> | Promise<T>, successCallback: (arg: T) => any, failureCallback?: (arg: Error) => any): void;
}

/**
 * @ngdoc service
 * @name functionsModule
 *
 * @description
 * provides a list of useful functions that can be used as part of the SmartEdit framework.
 */
export class FunctionsModule {
}


/**
 * @ngdoc service
 * @name functionsModule.service:FunctionsUtils
 *
 * @description
 * utility service around Functions.
 */
export class FunctionsUtils {
    
    /**
     * @ngdoc method
     * @name functionsModule.service:FunctionsUtils#isEmpty
     * @methodOf functionsModule.service:FunctionsUtils
     *
     * @description
     * Will determine whether a function body is empty or should be considered empty for proxying purposes
     *
     * @param {Function} func, the function to evaluate
     * @returns {Boolean} a boolean.
     */
    isEmpty(func: (...args: any[]) => any): boolean;
    /**
     * @ngdoc method
     * @name functionsModule.service:FunctionsUtils#getArguments
     * @methodOf functionsModule.service:FunctionsUtils
     *
     * @description
     * Returns the array of string arguments of the given function signature
     *
     * @param {Function} func the function to analyze
     * @returns {string[]} an array of string arguments
     */
    getArguments(func: (...args: any[]) => any): string[];
    /**
     * @ngdoc method
     * @name functionsModule.service:FunctionsUtils#hasArguments
     * @methodOf functionsModule.service:FunctionsUtils
     *
     * @description
     * Determines whether a given function (anonymous or not) has arguments in it signature
     *
     * @param {Function} func the function to analyze
     * @returns {boolean} true if the function has signature arguments
     */
    hasArguments(func: (...args: any[]) => any): boolean;
    /**
     * @ngdoc method
     * @name functionsModule.service:FunctionsUtils#getConstructorName
     * @methodOf functionsModule.service:FunctionsUtils
     *
     * @description
     * Returns the constructor name in a cross browser fashion
     *
     * @param {Function} func the function to analyze
     * @returns {string} the constructor name
     */
    getConstructorName(func: new (...args: any[]) => any): string;
    /**
     * @ngdoc method
     * @name functionsModule.service:FunctionsUtils#getInstanceConstructorName
     * @methodOf functionsModule.service:FunctionsUtils
     *
     * @description
     * Returns the constructor name in a cross browser fashion of a class instance
     *
     * @param {Object} instance instance class to analyze
     * @returns {string} the constructor name of the instance
     */
    getInstanceConstructorName(instance: object): string;
    /**
     * @ngdoc method
     * @name functionsModule.service:FunctionsUtils#extendsConstructor
     * @methodOf functionsModule.service:FunctionsUtils
     *
     * @description
     * Overrides a given constructor with a new constructor body. The resulting constructor will share the same prototype as the original one.
     *
     * @param {(...args:any[]) => T} originalConstructor the original constructor to override
     * @returns {(...args:any[]) => T} newConstructorBody the new constructor body to execute in the override. It may or may not return an instance. Should it return an instance, the latter will be returned by the override.
     */
    extendsConstructor<T>(originalConstructor: (...args: any[]) => T, newConstructorBody: (...args: any[]) => T): any;
    /**
     * @ngdoc method
     * @name functionsModule.service:FunctionsUtils#getLodash
     * @methodOf functionsModule.service:FunctionsUtils
     *
     * @description
     * Returns lodash service instance in a portable way
     * This is onyl to be used in unit testing and runtime code where angular DI is not available
     * @returns {lodash.LoDashStatic} the instance of the lodash service
     */
    getLodash(): lo.LoDashStatic;
}
export const functionsUtils: FunctionsUtils;

export * from './UrlUtils';






/**
 * @ngdoc service
 * @name functionsModule.service:StringUtils
 *
 * @description
 * utility service around Strings.
 */
export class StringUtils {
    /**
     * @ngdoc method
     * @name functionsModule.regExpFactory
     * @name functionsModule.service:StringUtils#regExpFactory
     * @methodOf functionsModule.service:StringUtils
     *
     * @description
     * <b>regExpFactory</b> will convert a given pattern into a regular expression.
     * This method will prepend and append a string with ^ and $ respectively replaces
     * and wildcards (*) by proper regex wildcards.
     *
     * @param {String} pattern any string that needs to be converted to a regular expression.
     *
     * @returns {RegExp} a regular expression generated from the given string.
     *
     */
    regExpFactory(pattern: string): RegExp;
}
export const stringUtils: StringUtils;

/**
 * @ngdoc service
 * @name functionsModule.service:UrlUtils
 *
 * @description
 * A collection of utility methods for manipulating URLs
 */
export class UrlUtils {
    /**
     * @ngdoc method
     * @name functionsModule.service:UrlUtils#updateUrlParameter
     * @methodOf functionsModule.service:UrlUtils
     *
     * @description
     * Updates a URL to contain the query param and value provided. If already exists then it is updated,
     * if it did not previously exist, then it will be added.
     *
     * @param {String} url The url to be updated (this param will not be modified)
     * @param {String} key The query param key
     * @param {String} value The query param value
     *
     * @returns {String} The url with updated key/value
     */
    updateUrlParameter(url: string, key: string, value: string): string;
}


/**
 * @ngdoc service
 * @name functionsModule.service:WindowUtils
 *
 * @description
 * A collection of utility methods for windows.
 */
export class WindowUtils {
    
    
    
    constructor(isIframe: any, SMARTEDIT_IFRAME_ID: string, $window: angular.IWindowService);
    /**
     * @ngdoc method
     * @name functionsModule.service:WindowUtils#getTargetIFrame
     * @methodOf functionsModule.service:WindowUtils
     *
     * @description
     * Retrieves the iframe from the inner or outer app.
     *
     * @returns {Window} The content window or null if it does not exists.
     */
    getTargetIFrame(): Window;
}

}